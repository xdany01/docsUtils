<!DOCTYPE html>
<html lang="es">
<head>
    
    <meta charset="utf-8">
    <title>arrays-fn.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnsiColors.html">AnsiColors</a></li><li><a href="ArithmeticException.html">ArithmeticException</a></li><li><a href="Exception.html">Exception</a></li><li><a href="HttpClientException.html">HttpClientException</a></li><li><a href="IllegalArgumentException.html">IllegalArgumentException</a></li><li><a href="IllegalFormatException.html">IllegalFormatException</a></li><li><a href="IndexOutOfBoundsException.html">IndexOutOfBoundsException</a></li><li><a href="Logger.html">Logger</a><ul class='methods'><li data-type='method'><a href="Logger.html#.error">error</a></li><li data-type='method'><a href="Logger.html#.info">info</a></li><li data-type='method'><a href="Logger.html#.log">log</a></li><li data-type='method'><a href="Logger.html#.success">success</a></li><li data-type='method'><a href="Logger.html#.warning">warning</a></li></ul></li><li><a href="NullPointerException.html">NullPointerException</a></li><li><a href="OutOfMemoryException.html">OutOfMemoryException</a></li><li><a href="SelectorContent.html">SelectorContent</a><ul class='methods'><li data-type='method'><a href="SelectorContent.html#elementsToArray">elementsToArray</a></li><li data-type='method'><a href="SelectorContent.html#getAttributeValue">getAttributeValue</a></li><li data-type='method'><a href="SelectorContent.html#getCleanText">getCleanText</a></li><li data-type='method'><a href="SelectorContent.html#getContent">getContent</a></li><li data-type='method'><a href="SelectorContent.html#getElements">getElements</a></li><li data-type='method'><a href="SelectorContent.html#getHtml">getHtml</a></li><li data-type='method'><a href="SelectorContent.html#getValueOrDefault">getValueOrDefault</a></li><li data-type='method'><a href="SelectorContent.html#processMultipleSelectors">processMultipleSelectors</a></li><li data-type='method'><a href="SelectorContent.html#processSelector">processSelector</a></li><li data-type='method'><a href="SelectorContent.html#processSingleSelector">processSingleSelector</a></li></ul></li><li><a href="Sequence.html">Sequence</a><ul class='methods'><li data-type='method'><a href="Sequence.html#next">next</a></li></ul></li><li><a href="Task.html">Task</a><ul class='methods'><li data-type='method'><a href="Task.html#catch">catch</a></li><li data-type='method'><a href="Task.html#map">map</a></li><li data-type='method'><a href="Task.html#run">run</a></li><li data-type='method'><a href="Task.html#tap">tap</a></li><li data-type='method'><a href="Task.html#.from">from</a></li></ul></li><li><a href="TypeCastException.html">TypeCastException</a></li><li><a href="UnsupportedOperationException.html">UnsupportedOperationException</a></li><li><a href="Validator.html">Validator</a><ul class='methods'><li data-type='method'><a href="Validator.html#validateObject">validateObject</a></li><li data-type='method'><a href="Validator.html#.areArraySame">areArraySame</a></li><li data-type='method'><a href="Validator.html#.indexInRange">indexInRange</a></li><li data-type='method'><a href="Validator.html#.isArray">isArray</a></li><li data-type='method'><a href="Validator.html#.isBigInt">isBigInt</a></li><li data-type='method'><a href="Validator.html#.isBoolean">isBoolean</a></li><li data-type='method'><a href="Validator.html#.isEmpty">isEmpty</a></li><li data-type='method'><a href="Validator.html#.isEncoded">isEncoded</a></li><li data-type='method'><a href="Validator.html#.isFloat">isFloat</a></li><li data-type='method'><a href="Validator.html#.isFunction">isFunction</a></li><li data-type='method'><a href="Validator.html#.isInteger">isInteger</a></li><li data-type='method'><a href="Validator.html#.isNil">isNil</a></li><li data-type='method'><a href="Validator.html#.isNull">isNull</a></li><li data-type='method'><a href="Validator.html#.isNumber">isNumber</a></li><li data-type='method'><a href="Validator.html#.isObject">isObject</a></li><li data-type='method'><a href="Validator.html#.isOneDimensional">isOneDimensional</a></li><li data-type='method'><a href="Validator.html#.isString">isString</a></li><li data-type='method'><a href="Validator.html#.isSymbol">isSymbol</a></li><li data-type='method'><a href="Validator.html#.isType">isType</a></li><li data-type='method'><a href="Validator.html#.isUndefined">isUndefined</a></li><li data-type='method'><a href="Validator.html#.isValidType">isValidType</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-UtilsArrays.html">UtilsArrays</a></li><li><a href="module-UtilsNumbers.html">UtilsNumbers</a></li><li><a href="module-UtilsObject.html">UtilsObject</a></li><li><a href="module-UtilsString.html">UtilsString</a></li><li><a href="module-Various.html">Various</a><ul class='methods'><li data-type='method'><a href="module-Various.html#.bubbleSort">bubbleSort</a></li><li data-type='method'><a href="module-Various.html#.bucketSort">bucketSort</a></li><li data-type='method'><a href="module-Various.html#.convertirMilisegundos">convertirMilisegundos</a></li><li data-type='method'><a href="module-Various.html#.decimalToHex">decimalToHex</a></li><li data-type='method'><a href="module-Various.html#.decodeJWT">decodeJWT</a></li><li data-type='method'><a href="module-Various.html#.generateShades">generateShades</a></li><li data-type='method'><a href="module-Various.html#.generateUniqueId">generateUniqueId</a></li><li data-type='method'><a href="module-Various.html#.getComplementaryColor">getComplementaryColor</a></li><li data-type='method'><a href="module-Various.html#.getSuplementaryColor">getSuplementaryColor</a></li><li data-type='method'><a href="module-Various.html#.getTypeOf">getTypeOf</a></li><li data-type='method'><a href="module-Various.html#.getVariablesInText">getVariablesInText</a></li><li data-type='method'><a href="module-Various.html#.heapsort">heapsort</a></li><li data-type='method'><a href="module-Various.html#.hexToDecimal">hexToDecimal</a></li><li data-type='method'><a href="module-Various.html#.hexToHSL">hexToHSL</a></li><li data-type='method'><a href="module-Various.html#.hexToRgb">hexToRgb</a></li><li data-type='method'><a href="module-Various.html#.hslToHex">hslToHex</a></li><li data-type='method'><a href="module-Various.html#.hslToRgb">hslToRgb</a></li><li data-type='method'><a href="module-Various.html#.insertionSort">insertionSort</a></li><li data-type='method'><a href="module-Various.html#.measureAsyncFn">measureAsyncFn</a></li><li data-type='method'><a href="module-Various.html#.measureSyncFn">measureSyncFn</a></li><li data-type='method'><a href="module-Various.html#.mergeSort">mergeSort</a></li><li data-type='method'><a href="module-Various.html#.myDecodeURI">myDecodeURI</a></li><li data-type='method'><a href="module-Various.html#.myEncodeURI">myEncodeURI</a></li><li data-type='method'><a href="module-Various.html#.normalizeUrl">normalizeUrl</a></li><li data-type='method'><a href="module-Various.html#.parseJSONToString">parseJSONToString</a></li><li data-type='method'><a href="module-Various.html#.parseStringToJSON">parseStringToJSON</a></li><li data-type='method'><a href="module-Various.html#.pipe">pipe</a></li><li data-type='method'><a href="module-Various.html#.quickSort">quickSort</a></li><li data-type='method'><a href="module-Various.html#.randomBoolean">randomBoolean</a></li><li data-type='method'><a href="module-Various.html#.randomColorHex">randomColorHex</a></li><li data-type='method'><a href="module-Various.html#.rgbToHex">rgbToHex</a></li><li data-type='method'><a href="module-Various.html#.rgbToHsl">rgbToHsl</a></li><li data-type='method'><a href="module-Various.html#.selectionSort">selectionSort</a></li><li data-type='method'><a href="module-Various.html#.timestampToutc">timestampToutc</a></li><li data-type='method'><a href="module-Various.html#.wait">wait</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">arrays-fn.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module UtilsArrays
 */
export class UtilsArrays {

    /**
     * Permite mezclar los valores de una matriz unidimensional.
     * @param {any[]} arr Matriz unidimensional la cual se desea mezclar.
     * @returns {any[]} Retorna una matriz con los valores mezclados.
     * @example
     * shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
     * // [9, 1, 10, 6, 8, 5, 2, 3, 7, 4]
     * shuffle(['a','b','c','d','e','f','g','h']);
     * //['b', 'e', 'f', 'h', 'a', 'c', 'g', 'd']
     */
    static shuffle(arr) {
        if (arr === undefined || arr === null) {
            throw Error('El argumento arr no esta definido.');
        }
        if (!Array.isArray(arr)) {
            throw TypeError('El argumento arr no es una matriz.');
        }
        return arr
            .map((a) => ({ sort: Math.random(), value: a }))
            .sort((a, b) => a.sort - b.sort)
            .map((a) => a.value);
    }

    /**
     * Permite dividir una matriz en trozos.
     * @param {any[]} arr Es la matriz con la que se desea trabajar.
     * @param {Number} size Es el tamaño de los trozos en los cuales se desea dividir la matriz.
     * @returns {any[]} Retorna una matriz compuesta por los trozos especificados.
     * @example
     * chunk([1, 2, 3, 4, 5, 6, 7, 8], 3);
     * // [[1, 2, 3], [4, 5, 6], [7, 8]]
     * chunk([1, 2, 3, 4, 5, 6, 7, 8], 4);
     * // [[1, 2, 3, 4], [5, 6, 7, 8]]
     */
    static chunk(arr, size) {
        return arr.reduce((acc, e, i) => (i % size ? acc[acc.length - 1].push(e) : acc.push([e]), acc), []);
    }

    /**
     * Permite particionar una matriz según una condición.
     * @param {any[]} arr Es la matriz con la que se desea trabajar.
     * @param {static} criteria Predicado que evalua cada elemento.
     * @returns {any[]}
     * @example
     * partition([1, 2, 3, 4, 5], (n) => n % 2 === 0);
     * // [ [ 2, 4 ], [ 1, 3, 5 ] ]
     */
    static partition(arr, criteria) {
        return arr.reduce((acc, i) => (acc[criteria(i) ? 0 : 1].push(i), acc), [[], []]);
    }

    /**
     * Permite obtener la intersección de matrices.
     * @param {any[]} a Matriz principal de comparación.
     * @param {any[]} arr Sucesión de matrices para comparar.
     * @returns {any[]} Retorna un matriz con las coincidencias.
     * @example
     * getIntersection([1, 2, 3], [2, 3, 4, 5]);
     * // [2, 3]
     * getIntersection([1, 2, 3], [2, 3, 4, 5], [1, 3, 5]);
     * // [3]
     */
    static getIntersection(a, ...arr) {
        return [...new Set(a)].filter((v) => arr.every((b) => b.includes(v)));
    }

    /**
     * Permite comparar dos matrices.
     * @param {any[]} a Matriz a comparar.
     * @param {any[]} b Matriz a comparar.
     * @returns {boolean} Retorna `true` si son iguales y `false` si no lo son.
     * @example
     * isEqualArray([1, 2, 3], [1, 2, 3]);
     * // true
     * isEqualArray([1, 2, 3], [1, '2', 3]);
     * // false
     */
    static isEqualArray(a, b) {
        return a.length === b.length &amp;&amp; a.every((v, i) => v === b[i]);
    }

    /**
     * Permite cuentar las apariciones de elementos en una matriz unidimensional.
     * @param {any[]} arr Matriz unidimensional en la que se desea operar.
     * @param {*} val=null Valor opcional por el cual se desea contar las apariciones.
     * @returns {Object} Retorna un objeto con las apariciones y su cantidad.
     * @example
     * countOccurrences([2, 1, 3, 3, 2, 3]);
     * // { '1': 1, '2': 2, '3': 3 }
     * countOccurrences(['a', 'b', 'a', 'c', 'a', 'b']);
     * // { 'a': 3, 'b': 2, 'c': 1 }
     * // Usando el parametro val
     * countOccurrences([2, 1, 3, 3, 2, 3], 2);
     * // 2
     * countOccurrences(['a', 'b', 'a', 'c', 'a', 'b'], 'a');
     * // 3
     */
    static countOccurrences(arr, val = null) {
        if (val === null) {
            return arr.reduce((prev, curr) => ((prev[curr] = ++prev[curr] || 1), prev), {});

        }
        return arr.reduce((a, v) => (v === val ? a + 1 : a), 0);
    }

    /**
     * Permite obtener el promedio de una matriz de números.
     * @param {any[]} arr Matriz de números.
     * @returns {Number} Retorna el promedio de los números de la matriz.
     * @example
     * average([1,2,3,4]);
     * //2.5
     */
    static average(arr) {
        return arr.reduce((a, b) => a + b, 0) / arr.length;
    }

    /**
     * Permite crear una matriz de números en el rango dado.
     * @param {Number} min Mínimo valor de la matriz.
     * @param {Number} max Máximo valor de la matriz.
     * @returns {Number[]} Retorna una matriz de números consecutivos segun el min y el max indicado.
     * @example
     * range(5, 10);
     * // [5, 6, 7, 8, 9, 10]
     */
    static range(min, max) {
        return [...Array(max - min + 1).keys()].map((i) => i + min);
    }

    /**
     * Permite crear una matriz de suma acumulativa.
     * @param {Number[]} arr Matriz de números base.
     * @returns {Number[]} Retorna una matriz con los valores calculados.
     * @example
     * accumulate([1, 2, 3, 4]);
     * // [1, 3, 6, 10]
     * // 1             = 1
     * // 1 + 2         = 3
     * // 1 + 2 + 3     = 6
     * // 1 + 2 + 3 + 4 = 10
     */
    static accumulate(arr) {
        return arr.reduce((a, b, i) => (i === 0 ? [b] : [...a, b + a[i - 1]]), [0]);
    }

    /**
     * Encuentre el índice del primer elemento coincidente en una matriz
     * unidimensional de acuerdo al predicado indicado.
     * @param {any[]} arr Matriz unidimensional en la cual se desea realizar la busqueda.
     * @param {static} predicate Callback que debe retornar un `bool`.
     * @returns {Number} Retorna el índice del primer elemento que cumple
     * con el predicado indicado.
     * @example
     * lastIndex([1, 3, 5, 7, 9, 2, 4, 6, 8], (i) => i % 2 === 0);
     * // 5
     * lastIndex([1, 3, 5, 7, 9, 8, 6, 4, 2], (i) => i > 6);
     * // 3
     */
    static firstIndex(arr, predicate) {
        return arr.map((item) => predicate(item)).indexOf(true);
    }

    /**
     * Encuentre el índice del último elemento coincidente en una matriz
     * unidimensional de acuerdo al predicado indicado.
     * @param {any[]} arr Matriz unidimensional en la cual se desea realizar la busqueda.
     * @param {static} predicate Callback que debe retornar un `bool`.
     * @returns {Number} Retorna el índice del último elemento que cumple
     * con el predicado indicado.
     * @example
     * lastIndex([1, 3, 5, 7, 9, 2, 4, 6, 8], (i) => i % 2 === 1);
     * // 4
     * lastIndex([1, 3, 5, 7, 9, 8, 6, 4, 2], (i) => i > 6);
     * // 5
     */
    static lastIndex(arr, predicate) {
        return arr.map((item) => predicate(item)).lastIndexOf(true);
    }

    /**
     * Encuentra el índice del elemento mínimo de una matriz.
     * @param {any[]} arr Matriz de la cual se desea conseguir el índice del elemento mínimo.
     * @returns {Number} Retorna el índice del elemento correspondiente al mínimo valor.
     * @example
     * indexOfMin([6, 4, 8, 2, 10]);
     * // 3
     * indexOfMin([6, 4, 2, 2, 10]);
     * // 2
     */
    static indexOfMin(arr) {
        return arr.reduce((prev, curr, i, a) => (curr &lt; a[prev] ? i : prev), 0);
    }

    /**
     * Encuentra el índice del elemento máximo de una matriz.
     * @param {any[]} arr Matriz de la cual se desea conseguir el índice del elemento máximo.
     * @returns {Number} Retorna el índice del elemento correspondiente al máximo valor.
     * @example
     * indexOfMax([6, 4, 8, 2, 10]);
     * // 4
     * indexOfMax([6, 4, 2, 10, 10]);
     * // 3
     */
    static indexOfMax(arr) {
        return arr.reduce((prev, curr, i, a) => (curr > a[prev] ? i : prev), 0);
    }

    /**
     * Permite intercambiar la posición dos elementos de la matriz suministrada.
     * @param {any[]} arr Matriz de la cual se desea intercambiar elementos.
     * @param {Number} destination Índice del elemento de destinación.
     * @param {Number} source Índice del elemento de origen.
     * @returns {any[]} Retorna una matriz con los elementos intercambiados.
     * @example
     * swapItems([1, 2, 3, 4, 5], 1, 4);
     * // [1, 5, 3, 4, 2]
     */
    static swapItems(arr, destination, source) {
        return (arr[destination] &amp;&amp; arr[source] &amp;&amp; [...arr.slice(0, destination), arr[source], ...arr.slice(destination + 1, source), arr[destination], ...arr.slice(source + 1)]) || arr;
    }

    /**
     * Permite eliminar valores duplicados en una matriz unidimensional.
     * @param {any[]} arr Matriz a la cual se le desea remover los elementos duplicados.
     * @returns {any[]}
     * @example
     * removeDuplicate([1, 1, 2, 3, 4, 5, 1, 3, 6])
     * // [ 2, 4, 5, 6 ]
     */
    static removeDuplicate(arr) {
        return arr.filter((i) => arr.indexOf(i) === arr.lastIndexOf(i));
    }

    /**
     * Permite obtener un elemento aleatorio de una matriz.
     * @param {any[]} arr Matriz base
     * @returns {*}
     */
    static randomItem(arr) {
        return arr[(Math.random() * arr.length) | 0];
    }


    /**
     * Permite obtener los índices de un valor buscado en una matriz unidimensional.
     * @param {any[]} arr Matriz unidimensional que es el origen de datos.
     * @param value Valor que se busca en la matriz unidimensional.
     * @returns {Number[]} Retorna un array con los índices de las coincidencias encontradas.
     * Si no encuentra ninguna coincidencia retorna un array vacio.
     * @example
     * indices(['h', 'e', 'l', 'l', 'o'], 'l');
     * // [2, 3]
     * indices(['h', 'e', 'l', 'l', 'o'], 'w');
     * // []
     */
    static indices(arr, value) {
        return arr.reduce((acc, v, i) => (v === value ? [...acc, i] : acc), []);
    }

    /**
     * Esta función se utiliza para eliminar elementos duplicados de un array de objetos.
     * Funciona convirtiendo cada objeto en una cadena JSON y utilizando un Set para
     * almacenar solo las cadenas únicas, luego convierte esas cadenas nuevamente en
     * objetos antes de devolver el array resultante sin duplicados.
     * @param {Object[]} arr Matriz de objetos con elementos duplicados.
     * @returns {Object[]} Retorna una matriz de objetos sin duplicados.
     * @example
     * // Definir un array con objetos que pueden tener duplicados
     * const arrayConDuplicados = [
     *   { id: 1, name: 'John' },
     *   { id: 2, name: 'Jane' },
     *   { id: 1, name: 'John' }, // Duplicado
     *   { id: 3, name: 'Doe' },
     *   { id: 2, name: 'Jane' }, // Duplicado
     * ];
     *
     * // Llamar a la función para eliminar duplicados
     * const arraySinDuplicados = removeDuplicatesArrObj(arrayConDuplicados);
     *
     * console.log(arraySinDuplicados);
     * // [
     * //  { id: 1, name: 'John' },
     * //  { id: 2, name: 'Jane' },
     * //  { id: 3, name: 'Doe' }
     * // ]
     */
    static removeDuplicatesArrObj(arr) {
        const uniqueObjects = new Set();
        arr.forEach((item) => {
            uniqueObjects.add(JSON.stringify(item));
        });
        return Array.from(uniqueObjects).map((item) => JSON.parse(item));
    }

    /**
     * Este método busca el primer objeto en un array que
     * cumpla con una condición de coincidencia de expresiones regulares
     * con un texto dado.
     * @param {Object[]} arr Array de objetos de promociones con su respectiva regex.
     * @param {string} txt Texto a machear.
     * @returns {Object | undefined} Retorna el objeto si hay coincidencia o undefined si no la hay.
     * @example
     * const promotions = [
     *     {name: 'promotion 1', regex: new RegExp(/\$,\d/)},
     *     {name: 'promotion 2', regex: new RegExp(/\$\.\d/)},
     *     {name: 'promotion 3', regex: new RegExp(/\d/)},
     *     {name: 'promotion 4', regex: new RegExp(/\$\d/)}
     * ];
     *
     * console.log(firstObjMatch(promotions, '$25'));
     * //{ name: 'promotion 4', regex: reg4 }
     */
    static firstObjMatch(arr, txt) {
        return arr.filter(e => e.regex.test(txt))[0];
    }

    /**
     * Inserta uno o más elementos en un array en un índice dado sin reemplazar ningún elemento.
     *
     * @param {Array} arr - El array original donde se insertarán los elementos.
     * @param {number} index - El índice a partir del cual se insertarán los elementos.
     * @param {...any} elements - Los elementos a insertar en el array.
     * @returns {Array} - El array con los elementos insertados.
     * @example
     * // Ejemplo de uso con objetos:
     * let arr = [
     *     {id: 1, name: 'a'},
     *     {id: 2, name: 'b'},
     *     {id: 5, name: 'e'}
     * ];
     *
     * insertElements(arr, 2, {id: 3, name: 'c'}, {id: 4, name: 'd'},);
     * // Resultado:
     * // [
     * //     { id: 1, name: 'a' },
     * //     { id: 2, name: 'b' },
     * //     { id: 3, name: 'c' },
     * //     { id: 4, name: 'd' },
     * //     { id: 5, name: 'e' }
     * // ]
     */
    static insertElements(arr, index, ...elements) {
        // Verificar que arr es un array
        if (!Array.isArray(arr)) {
            throw new Error('El primer argumento debe ser un array');
        }
        // Verificar si el índice está dentro del rango del array
        if (index &lt; 0 || index > arr.length) {
            throw new Error('Índice fuera de rango');
        }
        // Usar splice para insertar los elementos sin eliminar ninguno
        arr.splice(index, 0, ...elements);
        return arr;
    }

    /**
     * Función para generar un array de objetos a partir de dos arrays dados.
     * @param {Array} arr1 - El primer array.
     * @param {Array} arr2 - El segundo array.
     * @param {Array} [keys=['key','value']] - Las claves para los objetos en el array resultante.
     * @returns {Array} - Un array de objetos con las claves especificadas.
     * @example
     * // Ejemplo de uso
     * const arr1 = ['a', 'b', 'c'];
     * const arr2 = [1, 2, 3];
     * const keys = ['key', 'value'];
     *
     * const result = generateObjectArray(arr1, arr2, keys);
     * console.log(result);
     * [
     *   { key: 'a', value: 1 },
     *   { key: 'b', value: 2 },
     *   { key: 'c', value: 3 }
     * ]
     */
    static generateObjectArray(arr1, arr2, keys = ['key', 'value']) {
        // Verificar si los dos arreglos tienen la misma longitud
        if (arr1.length !== arr2.length) {
            throw new Error("Los dos arreglos deben tener la misma longitud");
        }

        // Mapear los elementos de arr1 y arr2 a un nuevo objeto con las claves especificadas
        return arr1.map((item, index) => ({
            [keys[0]]: item,
            [keys[1]]: arr2[index]
        }));
    }

    /**
     * Combina dos arrays siguiendo segmentos definidos para cada uno.
     *
     * @param {Array} arrayA - Primer array de entrada.
     * @param {Array} arrayB - Segundo array de entrada.
     * @param {Array&lt;(number|string)>} segmentosA - Segmentos de elementos a tomar de arrayA.
     * @param {Array&lt;(number|string)>} segmentosB - Segmentos de elementos a tomar de arrayB.
     * @returns {Array} - Nuevo array combinado según los segmentos.
     */
    static unionArrays(arrayA, arrayB, segmentosA, segmentosB) {
        // Validación de entrada
        if (segmentosA.length !== segmentosB.length) {
            throw new Error("Los arreglos de segmentos deben tener la misma longitud.");
        }
        const resultado = [];
        let indiceA = 0;
        let indiceB = 0;
        // Función auxiliar para tomar 'n' elementos de un array
        const tomarElementos = (array, indice, cantidad) => array.slice(indice, indice + cantidad);
        // Iteramos sobre los segmentos definidos
        for (let i = 0; i &lt; segmentosA.length; i++) {
            // Manejo de segmentos en arrayA
            if (segmentosA[i] === 'resto') {
                resultado.push(...arrayA.slice(indiceA));
                indiceA = arrayA.length; // Todos los elementos restantes se han tomado
            } else if (typeof segmentosA[i] === 'number' &amp;&amp; segmentosA[i] > 0) {
                resultado.push(...tomarElementos(arrayA, indiceA, segmentosA[i]));
                indiceA += segmentosA[i];
            }
            // Manejo de segmentos en arrayB
            if (segmentosB[i] === 'resto') {
                resultado.push(...arrayB.slice(indiceB));
                indiceB = arrayB.length; // Todos los elementos restantes se han tomado
            } else if (typeof segmentosB[i] === 'number' &amp;&amp; segmentosB[i] > 0) {
                resultado.push(...tomarElementos(arrayB, indiceB, segmentosB[i]));
                indiceB += segmentosB[i];
            }
        }
        return resultado;
    }

    /**
     * Función que ordena elementos basándose en un arreglo de texto.
     * @param {Array} elements - Arreglo de elementos a ordenar.
     * @param {Array} arrayText - Arreglo de texto que define el orden.
     * @param {string} property - Propiedad del elemento que se utilizará para la comparación.
     * @returns {Array} - Arreglo de elementos ordenados según el arreglo de texto.
     */
    static sortElementsByArrayOfText(elements, arrayText, property) {
        // Verifica si el arreglo de elementos o el arreglo de texto están vacíos.
        if (!elements.length || !arrayText.length) return []; // Retorna un arreglo vacío si alguno de los arreglos está vacío.

        // Crea un mapa donde la clave es el texto de la propiedad especificada y el valor es el elemento correspondiente.
        const elementsMap = new Map(elements.map(el => [el[property].trim(), el]));

        // Mapea el arreglo de texto a los elementos del mapa y filtra los valores no válidos.
        return arrayText.map(text => elementsMap.get(text)).filter(Boolean); // Retorna un arreglo de elementos ordenados.
    }

}
</code></pre>
        </article>
    </section>





    
</div>

<br class="clear">

<footer>
    Hecho con <small>❤</small> por <a
        href="https://github.com/xdany01">@xdany01</a> usando la plantilla de <a
        href="https://github.com/clenemt/docdash">docdash</a>.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
