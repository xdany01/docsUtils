<!DOCTYPE html>
<html lang="es">
<head>
    
    <meta charset="utf-8">
    <title>various-fn.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Arrays.html">Arrays</a><ul class='methods'><li data-type='method'><a href="module-Arrays.html#~accumulate">accumulate</a></li><li data-type='method'><a href="module-Arrays.html#~average">average</a></li><li data-type='method'><a href="module-Arrays.html#~chunk">chunk</a></li><li data-type='method'><a href="module-Arrays.html#~countOccurrences">countOccurrences</a></li><li data-type='method'><a href="module-Arrays.html#~firstIndex">firstIndex</a></li><li data-type='method'><a href="module-Arrays.html#~firstObjMatch">firstObjMatch</a></li><li data-type='method'><a href="module-Arrays.html#~generateObjectArray">generateObjectArray</a></li><li data-type='method'><a href="module-Arrays.html#~getIntersection">getIntersection</a></li><li data-type='method'><a href="module-Arrays.html#~indexOfMax">indexOfMax</a></li><li data-type='method'><a href="module-Arrays.html#~indexOfMin">indexOfMin</a></li><li data-type='method'><a href="module-Arrays.html#~indices">indices</a></li><li data-type='method'><a href="module-Arrays.html#~insertElements">insertElements</a></li><li data-type='method'><a href="module-Arrays.html#~isEqualArray">isEqualArray</a></li><li data-type='method'><a href="module-Arrays.html#~lastIndex">lastIndex</a></li><li data-type='method'><a href="module-Arrays.html#~partition">partition</a></li><li data-type='method'><a href="module-Arrays.html#~randomItem">randomItem</a></li><li data-type='method'><a href="module-Arrays.html#~range">range</a></li><li data-type='method'><a href="module-Arrays.html#~removeDuplicate">removeDuplicate</a></li><li data-type='method'><a href="module-Arrays.html#~removeDuplicatesArrObj">removeDuplicatesArrObj</a></li><li data-type='method'><a href="module-Arrays.html#~shuffle">shuffle</a></li><li data-type='method'><a href="module-Arrays.html#~swapItems">swapItems</a></li></ul></li><li><a href="module-Numbers.html">Numbers</a><ul class='methods'><li data-type='method'><a href="module-Numbers.html#.randomNumberGenerator">randomNumberGenerator</a></li><li data-type='method'><a href="module-Numbers.html#.toFixed">toFixed</a></li></ul></li><li><a href="module-Objects.html">Objects</a><ul class='methods'><li data-type='method'><a href="module-Objects.html#.combinedObjectWithArrays">combinedObjectWithArrays</a></li><li data-type='method'><a href="module-Objects.html#.commonKeys">commonKeys</a></li><li data-type='method'><a href="module-Objects.html#.countBy">countBy</a></li><li data-type='method'><a href="module-Objects.html#.getCommonKeys">getCommonKeys</a></li><li data-type='method'><a href="module-Objects.html#.getObjFromKey">getObjFromKey</a></li><li data-type='method'><a href="module-Objects.html#.groupBy">groupBy</a></li><li data-type='method'><a href="module-Objects.html#.isEqualObj">isEqualObj</a></li><li data-type='method'><a href="module-Objects.html#.maxBy">maxBy</a></li><li data-type='method'><a href="module-Objects.html#.minBy">minBy</a></li><li data-type='method'><a href="module-Objects.html#.pluck">pluck</a></li><li data-type='method'><a href="module-Objects.html#.removeArrayFromValues">removeArrayFromValues</a></li><li data-type='method'><a href="module-Objects.html#.removeDuplicatesByProperty">removeDuplicatesByProperty</a></li><li data-type='method'><a href="module-Objects.html#.removeDuplicatesFromValues">removeDuplicatesFromValues</a></li><li data-type='method'><a href="module-Objects.html#.removeNullUndefined">removeNullUndefined</a></li><li data-type='method'><a href="module-Objects.html#.removeObjectSafely">removeObjectSafely</a></li><li data-type='method'><a href="module-Objects.html#.renameKeys">renameKeys</a></li><li data-type='method'><a href="module-Objects.html#.sortBy">sortBy</a></li><li data-type='method'><a href="module-Objects.html#.sortObj">sortObj</a></li><li data-type='method'><a href="module-Objects.html#.splitObjInKeys">splitObjInKeys</a></li><li data-type='method'><a href="module-Objects.html#.toObject">toObject</a></li></ul></li><li><a href="module-String.html">String</a><ul class='methods'><li data-type='method'><a href="module-String.html#.bytesString">bytesString</a></li><li data-type='method'><a href="module-String.html#.camelToKebab">camelToKebab</a></li><li data-type='method'><a href="module-String.html#.capitalize">capitalize</a></li><li data-type='method'><a href="module-String.html#.characterCount">characterCount</a></li><li data-type='method'><a href="module-String.html#.cleanText">cleanText</a></li><li data-type='method'><a href="module-String.html#.concatWS">concatWS</a></li><li data-type='method'><a href="module-String.html#.countWords">countWords</a></li><li data-type='method'><a href="module-String.html#.decodeHtmlEntities">decodeHtmlEntities</a></li><li data-type='method'><a href="module-String.html#.decomposeUrl">decomposeUrl</a></li><li data-type='method'><a href="module-String.html#.ext">ext</a></li><li data-type='method'><a href="module-String.html#.generateString">generateString</a></li><li data-type='method'><a href="module-String.html#.isPalindrome">isPalindrome</a></li><li data-type='method'><a href="module-String.html#.kebabToCamel">kebabToCamel</a></li><li data-type='method'><a href="module-String.html#.mask">mask</a></li><li data-type='method'><a href="module-String.html#.prependNumbers">prependNumbers</a></li><li data-type='method'><a href="module-String.html#.removeAcents">removeAcents</a></li><li data-type='method'><a href="module-String.html#.removeEmptyLines">removeEmptyLines</a></li><li data-type='method'><a href="module-String.html#.replaceSpaces">replaceSpaces</a></li><li data-type='method'><a href="module-String.html#.slugify">slugify</a></li><li data-type='method'><a href="module-String.html#.sortLines">sortLines</a></li><li data-type='method'><a href="module-String.html#.toCamelCase">toCamelCase</a></li><li data-type='method'><a href="module-String.html#.toPascalCase">toPascalCase</a></li><li data-type='method'><a href="module-String.html#.trim">trim</a></li><li data-type='method'><a href="module-String.html#.truncate">truncate</a></li><li data-type='method'><a href="module-String.html#.upperCaseWords">upperCaseWords</a></li></ul></li><li><a href="module-Validators.html">Validators</a><ul class='methods'><li data-type='method'><a href="module-Validators.html#.checkDataTypeObj">checkDataTypeObj</a></li><li data-type='method'><a href="module-Validators.html#.equalArrays">equalArrays</a></li><li data-type='method'><a href="module-Validators.html#.indexInRange">indexInRange</a></li><li data-type='method'><a href="module-Validators.html#.isArray">isArray</a></li><li data-type='method'><a href="module-Validators.html#.isEmptyObj">isEmptyObj</a></li><li data-type='method'><a href="module-Validators.html#.isInteger">isInteger</a></li><li data-type='method'><a href="module-Validators.html#.isOneDimensional">isOneDimensional</a></li><li data-type='method'><a href="module-Validators.html#.isType">isType</a></li><li data-type='method'><a href="module-Validators.html#.isUndefinedOrNull">isUndefinedOrNull</a></li><li data-type='method'><a href="module-Validators.html#.isValidType">isValidType</a></li></ul></li><li><a href="module-Various.html">Various</a><ul class='methods'><li data-type='method'><a href="module-Various.html#.bubbleSort">bubbleSort</a></li><li data-type='method'><a href="module-Various.html#.bucketSort">bucketSort</a></li><li data-type='method'><a href="module-Various.html#.decodeJWT">decodeJWT</a></li><li data-type='method'><a href="module-Various.html#.generateShades">generateShades</a></li><li data-type='method'><a href="module-Various.html#.getComplementaryColor">getComplementaryColor</a></li><li data-type='method'><a href="module-Various.html#.getSuplementaryColor">getSuplementaryColor</a></li><li data-type='method'><a href="module-Various.html#.getTypeOf">getTypeOf</a></li><li data-type='method'><a href="module-Various.html#.heapsort">heapsort</a></li><li data-type='method'><a href="module-Various.html#.hexToHSL">hexToHSL</a></li><li data-type='method'><a href="module-Various.html#.hexToRgb">hexToRgb</a></li><li data-type='method'><a href="module-Various.html#.hslToHex">hslToHex</a></li><li data-type='method'><a href="module-Various.html#.hslToRgb">hslToRgb</a></li><li data-type='method'><a href="module-Various.html#.insertionSort">insertionSort</a></li><li data-type='method'><a href="module-Various.html#.mergeSort">mergeSort</a></li><li data-type='method'><a href="module-Various.html#.myDecodeURI">myDecodeURI</a></li><li data-type='method'><a href="module-Various.html#.myEncodeURI">myEncodeURI</a></li><li data-type='method'><a href="module-Various.html#.parseStringToJSON">parseStringToJSON</a></li><li data-type='method'><a href="module-Various.html#.pipe">pipe</a></li><li data-type='method'><a href="module-Various.html#.quickSort">quickSort</a></li><li data-type='method'><a href="module-Various.html#.randomColorHex">randomColorHex</a></li><li data-type='method'><a href="module-Various.html#.rgbToHex">rgbToHex</a></li><li data-type='method'><a href="module-Various.html#.rgbToHsl">rgbToHsl</a></li><li data-type='method'><a href="module-Various.html#.selectionSort">selectionSort</a></li><li data-type='method'><a href="module-Various.html#.wait">wait</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">various-fn.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module Various
 */

/**
 * La función `wait` devuelve una promesa que se resuelve
 * después de esperar la cantidad de tiempo especificada
 * en milisegundos (valor por defecto 1 segundo).
 * Esto puede ser útil en situaciones donde necesitas pausar
 * la ejecución de cierto código durante un período de tiempo
 * específico, como en operaciones asíncronas o en situaciones
 * donde necesitas controlar el flujo de ejecución de manera temporal.
 * @param {number} ms=1000 Cantidad de milisegundos a esperar.
 * @returns {Promise} Retorna una promesa que no resuelve nada.
 * @example
 * console.log('Inicio del programa');
 *
 * wait(2000) // Espera 2 segundos (2000 milisegundos)
 *   .then(() => {
 *     console.log('Han pasado 2 segundos');
 *     return wait(3000); // Espera 3 segundos adicionales
 *   })
 *   .then(() => {
 *     console.log('Han pasado 5 segundos en total');
 *   });
 *
 * console.log('Fin del programa');
 * // Inicio del programa
 * // Fin del programa
 * // Han pasado 2 segundos
 * // Han pasado 5 segundos en total
 * @example
 * console.log('Inicio del programa');
 * await wait(); // Espera 1 segundo (1000 milisegundos)
 * console.log('Continua la ejecución del programa');
 */
export function wait(ms = 1000) {
    return new Promise((resuelve) => setTimeout(resuelve, ms))
}

/**
 * Permite decodificar un token JWT.
 * @param {string} token Token a decodificar.
 * @returns {Object} Retorna un objeto con los datos decodificados.
 * @example
 * decode(`
 *     eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
 *     eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0I
 *     joxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
 * `);
 *
 * // { "sub": "1234567890", "name": "John Doe", "iat": 1516239022 }
 */
export function decodeJWT(token) {
    return decodeURIComponent(atob(token.split('.')[1].replace('-', '+').replace('_', '/'))
        .split('')
        .map((c) => `%${('00' + c.charCodeAt(0).toString(16)).slice(-2)}`)
        .join(''));
}

/**
 * Permite obtener el tipo de una variable en un string.
 * @param obj Variable que se desea conocer el tipo.
 * @returns {string} Retorna un string con el nombre del tipo de variable.
 * @example
 * getTypeOf('hello world'); // String
 * getTypeOf(1000); // Number
 * getTypeOf(Infinity); // Number
 * getTypeOf(true); // Boolean
 * getTypeOf(Symbol()); // Symbol
 * getTypeOf(null); // Null
 * getTypeOf(undefined); // Undefined
 * getTypeOf({}); // Object
 * getTypeOf([]); // Array
 * getTypeOf(/[a-z]/g); // RegExp
 * getTypeOf(new Date(2021)); // Date
 * getTypeOf(new Error()); // Error
 * getTypeOf(function () {}); // Function
 * getTypeOf((a, b) => a + b); // Function
 * getTypeOf(async () => {}); // AsyncFunction
 * getTypeOf(document); // HTMLDocument
 */
export function getTypeOf(obj) {
    return Object.prototype.toString.call(obj).match(/\[object (.*)\]/)[1];
}

/**
 * Genera un ramdom color hex.
 * @returns {string} Retorna el color en hex.
 * @example
 * randomColorHex()
 * //#060c7c
 */
export function randomColorHex() {
    return `#${Math.random().toString(16).slice(2, 8).padEnd(6, '0')}`;
}

/**
 * Codificar una URL
 * @param url URL a codificar.
 * @returns {string} Retorna la URL codificada.
 */
export function myEncodeURI(url) {
    return encodeURIComponent(url)
        .replace(/!/g, '%21')
        .replace(/~/g, '%7E')
        .replace(/\*/g, '%2A')
        .replace(/'/g, '%27')
        .replace(/\(/g, '%28')
        .replace(/\)/g, '%29')
        .replace(/\+/g, '%20');
}

/**
 * Decodificar una URL
 * @param url URL a decodificar.
 * @returns {string} Retorna la URL decodificada.
 */
export function myDecodeURI(url) {
    return decodeURIComponent(url)
        .replace(/%21/g, '!')
        .replace(/%7E/g, '~')
        .replace(/%2A/g, '*')
        .replace(/%27/g, "'")
        .replace(/%28/g, '(')
        .replace(/%29/g, ')')
        .replace(/%20/g, '+');
}

/**
 * Función que implementa una tubería de funciones.
 * @param {...Function} functions - Funciones a ser ejecutadas en orden.
 * @returns {Function} - Función que ejecuta las funciones en secuencia.
 */
export function pipe(...functions) {
    return input =>
        functions.reduce((acc, fn) => fn(acc), input);
}

/**
 * Convierte un color en formato hexadecimal a HSL (Hue, Saturation, Lightness).
 * @param {string} hex - Color en formato hexadecimal.
 * @returns {Array} - Array con los valores HSL.
 */
export function hexToHSL(hex) {
    let r = 0, g = 0, b = 0; // Inicializa los valores de rojo, verde y azul.
    if (hex.length === 4) { // Verifica si el color es de 4 dígitos.
        r = parseInt(hex[1] + hex[1], 16); // Calcula el valor de rojo.
        g = parseInt(hex[2] + hex[2], 16); // Calcula el valor de verde.
        b = parseInt(hex[3] + hex[3], 16); // Calcula el valor de azul.
    } else if (hex.length === 7) { // Verifica si el color es de 7 dígitos.
        r = parseInt(hex[1] + hex[2], 16); // Calcula el valor de rojo.
        g = parseInt(hex[3] + hex[4], 16); // Calcula el valor de verde.
        b = parseInt(hex[5] + hex[6], 16); // Calcula el valor de azul.
    }
    r /= 255; // Normaliza el valor de rojo.
    g /= 255; // Normaliza el valor de verde.
    b /= 255; // Normaliza el valor de azul.
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h = 0, s = 0, l = (max + min) / 2; // Calcula los valores de máximo, mínimo, matiz, saturación y luminosidad.
    if (max !== min) { // Verifica si el color no es una escala de grises.
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g &lt; b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return [h, s, l]; // Devuelve el array con los valores HSL.
}

/**
 * Convierte un color de formato HSL a formato hexadecimal.
 * @param {number} h - Matiz (hue) en grados.
 * @param {number} s - Saturación (saturation) en porcentaje.
 * @param {number} l - Luminosidad (lightness) en porcentaje.
 * @returns {string} - Color en formato hexadecimal.
 */
export function hslToHex(h, s, l) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l; // Si la saturación es 0, el color es acromático.
    } else {
        const hue2rgb = (p, q, t) => {
            if (t &lt; 0) t += 1;
            if (t > 1) t -= 1;
            if (t &lt; 1 / 6) return p + (q - p) * 6 * t;
            if (t &lt; 1 / 2) return q;
            if (t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        let q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    r = Math.round(r * 255);
    g = Math.round(g * 255);
    b = Math.round(b * 255);

    return "#" + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);
}

/**
 * Función para obtener el color complementario de un color en formato hexadecimal.
 * @param {string} hex - Color en formato hexadecimal.
 * @returns {string} - Color complementario en formato hexadecimal.
 */
export function getComplementaryColor(hex) {
    let [h, s, l] = hexToHSL(hex);
    h = (h + 0.5) % 1.0; // Sumar 180 grados al matiz para obtener el color complementario
    return hslToHex(h, s, l);
}

/**
 * Convierte un color hexadecimal a RGB.
 * @param {string} hex - Color hexadecimal a convertir.
 * @returns {Array} - Arreglo con los valores RGB.
 */
export function hexToRgb(hex) {
    // Eliminar el signo # si está presente
    hex = hex.replace(/^#/, '');

    // Convertir el color hexadecimal a RGB
    let bigint = parseInt(hex, 16);
    let r = (bigint >> 16) &amp; 255; // Extraer el componente rojo
    let g = (bigint >> 8) &amp; 255; // Extraer el componente verde
    let b = bigint &amp; 255; // Extraer el componente azul

    return [r, g, b]; // Devolver un arreglo con los valores RGB
}

/**
 * Convierte los valores RGB a hexadecimal.
 * @param {number} r - Valor de rojo (0-255).
 * @param {number} g - Valor de verde (0-255).
 * @param {number} b - Valor de azul (0-255).
 * @returns {string} Representación hexadecimal del color RGB.
 */
export function rgbToHex(r, g, b) {
    // Se realiza la conversión de los valores RGB a su representación hexadecimal
    return "#" + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1).toUpperCase();
}

/**
 * Convierte un color RGB a HSL (Hue, Saturation, Lightness).
 * @param {number} r - Valor de rojo (0-255).
 * @param {number} g - Valor de verde (0-255).
 * @param {number} b - Valor de azul (0-255).
 * @returns {Array} - Array con los valores de HSL.
 */
export function rgbToHsl(r, g, b) {
    // Normalizar los valores RGB al rango 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    let max = Math.max(r, g, b);
    let min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // Si el máximo y el mínimo son iguales, el color es gris
    } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g &lt; b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }

    return [h * 360, s, l]; // Devuelve los valores de HSL
}

/**
 * Convierte un color de formato HSL a RGB.
 * @param {number} h - Matiz (hue) en grados.
 * @param {number} s - Saturación (saturation) como un valor entre 0 y 1.
 * @param {number} l - Luminosidad (lightness) como un valor entre 0 y 1.
 * @returns {Array} - Un arreglo con los valores RGB resultantes.
 */
export function hslToRgb(h, s, l) {
    let r, g, b;

    if (s === 0) {
        // Si la saturación es 0, el color es una escala de grises
        r = g = b = l;
    } else {
        function hue2rgb(p, q, t) {
            if (t &lt; 0) t += 1;
            if (t > 1) t -= 1;
            if (t &lt; 1 / 6) return p + (q - p) * 6 * t;
            if (t &lt; 1 / 3) return q;
            if (t &lt; 1 / 2) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }

        let q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        h /= 360;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r * 255, g * 255, b * 255];
}

/**
 * Función para obtener el color suplementario de un color hexadecimal.
 * @param {string} hex - Color hexadecimal.
 * @param {number} angle=25 - Ángulo para calcular el color suplementario.
 * @returns {string} Color hexadecimal suplementario.
 */
export function getSuplementaryColor(hex, angle = 25) {
    // Convertir el color hexadecimal a RGB
    let [r, g, b] = hexToRgb(hex);

    // Convertir RGB a HSL
    let [h, s, l] = rgbToHsl(r, g, b);

    // Calcular el nuevo tono (H) sumando el ángulo y asegurándose de que esté en el rango [0, 360)
    h = (h + angle) % 360;
    if (h &lt; 0) h += 360;

    // Convertir el nuevo HSL a RGB
    let [adjR, adjG, adjB] = hslToRgb(h, s, l);

    // Convertir el nuevo RGB a hexadecimal y devolverlo
    return rgbToHex(Math.round(adjR), Math.round(adjG), Math.round(adjB));
}

/**
 * Función para generar una serie de tonos a partir de un color hexadecimal dado.
 * @param {string} hex - Color hexadecimal base.
 * @param {number} numOfShades - Número de tonos a generar (por defecto 10).
 * @param {number} percentageDifference - Diferencia porcentual entre tonos adyacentes (por defecto 10).
 * @returns {Array} - Arreglo con los tonos generados.
 */
export function generateShades(hex, numOfShades = 10, percentageDifference = 10) {
    // Convertir el color hexadecimal a RGB
    let [r, g, b] = hexToRgb(hex);
    let shades = [];

    // Generar los tonos
    for (let i = 0; i &lt; numOfShades; i++) {
        // Calcular el factor de ajuste para el tono actual
        let factor = 1 + (percentageDifference / 100) * (i - Math.floor(numOfShades / 2));
        // Calcular los componentes RGB del tono
        let shadeR = Math.min(255, Math.max(0, Math.round(r * factor)));
        let shadeG = Math.min(255, Math.max(0, Math.round(g * factor)));
        let shadeB = Math.min(255, Math.max(0, Math.round(b * factor)));
        // Convertir los componentes RGB a color hexadecimal y agregarlo al arreglo de tonos
        shades.push(rgbToHex(shadeR, shadeG, shadeB));
    }

    return shades;
}

/**
 * Función que convierte una cadena en formato clave-valor a un objeto JSON.
 * @param {string} str - La cadena en formato clave-valor a convertir.
 * @param {string} separatorPair - El separador entre pares clave-valor (por defecto ';').
 * @param {string} separatorValue - El separador entre clave y valor (por defecto '=').
 * @returns {object} - Objeto JSON con las claves y valores extraídos de la cadena.
 */
export function parseStringToJSON(str, separatorPair = ';', separatorValue = '=') {
    const result = {};
    const pairs = str.split(separatorPair).map(pair => pair.trim()); // Divide la cadena en pares clave-valor y elimina espacios en blanco.
    pairs.forEach(pair => {
        const [key, value] = pair.split(separatorValue); // Divide el par en clave y valor.
        let parsedValue;
        if (value === undefined) { // Comprueba si el valor es indefinido.
            parsedValue = '';
        } else if (!isNaN(Number(value)) &amp;&amp; value.trim() !== '') { // Verifica si el valor es numérico.
            parsedValue = Number(value); // Convierte el valor a número.
        } else if (['true', 'false'].includes(value.toLowerCase())) { // Comprueba si el valor es booleano.
            parsedValue = value.toLowerCase() === 'true'; // Convierte el valor booleano a booleano.
        } else {
            parsedValue = value; // Asigna el valor como cadena.
        }
        result[key] = parsedValue; // Asigna el valor parseado a la clave correspondiente en el objeto JSON.
    });
    return result; // Devuelve el objeto JSON resultante.
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo de Quick Sort.
 * @param {Array} arr - El arreglo que se desea ordenar.
 * @returns {Array} - El arreglo ordenado.
 * @example
 * quickSort([1, 6, 1, 5, 3, 2, 1, 4]);
 * // [1, 1, 1, 2, 3, 4, 5, 6]
 */
export function quickSort(arr) {
    // Se crea una copia del arreglo para no modificar el original
    const a = [...arr];

    // Caso base: si el arreglo tiene menos de 2 elementos, se devuelve el arreglo
    if (a.length &lt; 2) return a;

    // Se calcula el índice del pivote
    const pivotIndex = Math.floor(arr.length / 2);
    const pivot = a[pivotIndex]; // Se obtiene el valor del pivote

    // Se separan los elementos menores y mayores que el pivote
    const [lo, hi] = a.reduce(
        (acc, val, i) => {
            if (val &lt; pivot || (val === pivot &amp;&amp; i != pivotIndex)) {
                acc[0].push(val); // Se añade al arreglo de menores
            } else if (val > pivot) {
                acc[1].push(val); // Se añade al arreglo de mayores
            }
            return acc;
        },
        [[], []]
    );

    // Se aplica recursivamente quickSort a los subarreglos menores y mayores, y se concatena con el pivote
    return [...quickSort(lo), pivot, ...quickSort(hi)];
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo Merge Sort.
 * @param {Array} arr - El arreglo a ordenar.
 * @returns {Array} - El arreglo ordenado.
 * @example
 * mergeSort([5, 1, 4, 2, 3]);
 * // [1, 2, 3, 4, 5]
 */
export function mergeSort(arr) {
    // Verificar si el arreglo tiene menos de 2 elementos
    if (arr.length &lt; 2) return arr;

    // Calcular el punto medio del arreglo
    const mid = Math.floor(arr.length / 2);

    // Dividir el arreglo en dos partes y llamar recursivamente a mergeSort
    const l = mergeSort(arr.slice(0, mid));
    const r = mergeSort(arr.slice(mid, arr.length));

    // Combinar y ordenar las dos partes del arreglo
    return Array.from({length: l.length + r.length}, () => {
        // Verificar si alguna de las partes ya no tiene elementos
        if (!l.length) return r.shift();
        else if (!r.length) return l.shift();
        // Comparar y combinar los elementos de las dos partes
        else return l[0] > r[0] ? r.shift() : l.shift();
    });
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo de heapsort.
 * @param {Array} arr - Arreglo a ordenar.
 * @returns {Array} - Arreglo ordenado.
 * @example
 * heapsort([6, 3, 4, 1]);
 * // [1, 3, 4, 6]
 */
export function heapsort(arr) {
    // Se crea una copia del arreglo para no modificar el original
    const a = [...arr];
    let l = a.length;

    // Función para convertir el arreglo en un heap
    const heapify = (a, i) => {
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        let max = i;
        if (left &lt; l &amp;&amp; a[left] > a[max]) max = left;
        if (right &lt; l &amp;&amp; a[right] > a[max]) max = right;
        if (max !== i) {
            [a[max], a[i]] = [a[i], a[max]];
            heapify(a, max);
        }
    };

    // Se convierte el arreglo en un heap
    for (let i = Math.floor(l / 2); i >= 0; i -= 1) heapify(a, i);

    // Se ordena el heap
    for (let i = a.length - 1; i > 0; i--) {
        [a[0], a[i]] = [a[i], a[0]];
        l--;
        heapify(a, 0);
    }
    return a;
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo de Bubble Sort.
 * @param {Array} arr - El arreglo a ordenar.
 * @returns {Array} - El arreglo ordenado.
 * @example
 * bubbleSort([2, 1, 4, 3]);
 * // [1, 2, 3, 4]
 */
export function bubbleSort(arr) {
    let swapped = false; // Variable para controlar si se realizó un intercambio en la iteración actual.
    const a = [...arr]; // Se crea una copia del arreglo para no modificar el original.
    for (let i = 1; i &lt; a.length; i++) { // Bucle externo para recorrer el arreglo.
        swapped = false; // Se reinicia la variable de intercambio en cada iteración.
        for (let j = 0; j &lt; a.length - i; j++) { // Bucle interno para comparar elementos y realizar intercambios.
            if (a[j + 1] &lt; a[j]) { // Si el elemento siguiente es menor que el actual, se intercambian.
                [a[j], a[j + 1]] = [a[j + 1], a[j]]; // Intercambio de elementos.
                swapped = true; // Se marca que se realizó un intercambio.
            }
        }
        if (!swapped) return a; // Si no se realizó ningún intercambio en la iteración, el arreglo está ordenado.
    }
    return a; // Se devuelve el arreglo ordenado.
}

/**
 * Función que implementa el algoritmo de ordenamiento por inserción.
 * @param {Array} arr - El arreglo que se va a ordenar.
 * @returns {Array} - El arreglo ordenado.
 */
export function insertionSort(arr) {
    return arr.reduce((acc, x) => {
        if (!acc.length) return [x]; // Si el arreglo está vacío, se agrega el primer elemento.
        acc.some((y, j) => {
            if (x &lt;= y) {
                acc.splice(j, 0, x); // Se inserta el elemento en la posición correcta.
                return true;
            }
            if (x > y &amp;&amp; j === acc.length - 1) {
                acc.splice(j + 1, 0, x); // Se inserta el elemento al final del arreglo.
                return true;
            }
            return false;
        });
        return acc;
    }, []);
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo de Selection Sort.
 * @param {Array} arr - El arreglo que se desea ordenar.
 * @returns {Array} - El arreglo ordenado.
 */
export function selectionSort(arr) {
    // Se crea una copia del arreglo para no modificar el original
    const a = [...arr];

    // Iteración sobre el arreglo
    for (let i = 0; i &lt; a.length; i++) {
        // Encontrar el índice del elemento mínimo en el subarreglo restante
        const min = a
            .slice(i + 1)
            .reduce((acc, val, j) => (val &lt; a[acc] ? j + i + 1 : acc), i);

        // Intercambiar elementos si es necesario
        if (min !== i) [a[i], a[min]] = [a[min], a[i]];
    }

    // Devolver el arreglo ordenado
    return a;
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo Bucket Sort.
 * @param {Array} arr - Arreglo a ordenar.
 * @param {number} size - Tamaño de los buckets (por defecto es 5).
 * @returns {Array} - Arreglo ordenado.
 */
export function bucketSort(arr, size = 5) {
    // Encontrar el valor mínimo y máximo en el arreglo
    const min = Math.min(...arr);
    const max = Math.max(...arr);

    // Crear los buckets basados en el tamaño y rango de valores
    const buckets = Array.from(
        {length: Math.floor((max - min) / size) + 1},
        () => []
    );

    // Colocar cada elemento del arreglo en el bucket correspondiente
    arr.forEach(val => {
        buckets[Math.floor((val - min) / size)].push(val);
    });

    // Ordenar cada bucket y combinarlos en un solo arreglo ordenado
    return buckets.reduce((acc, b) => [...acc, ...b.sort((a, b) => a - b)], []);
}


</code></pre>
        </article>
    </section>





    
</div>

<br class="clear">

<footer>
    Hecho con <small>❤</small> por <a
        href="https://github.com/xdany01">@xdany01</a> usando la plantilla de <a
        href="https://github.com/clenemt/docdash">docdash</a>.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
