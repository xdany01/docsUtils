<!DOCTYPE html>
<html lang="es">
<head>
    
    <meta charset="utf-8">
    <title>various-fn.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Validator.html">Validator</a><ul class='methods'><li data-type='method'><a href="Validator.html#.checkDataTypeObj">checkDataTypeObj</a></li><li data-type='method'><a href="Validator.html#.equalArrays">equalArrays</a></li><li data-type='method'><a href="Validator.html#.indexInRange">indexInRange</a></li><li data-type='method'><a href="Validator.html#.isArray">isArray</a></li><li data-type='method'><a href="Validator.html#.isBigInt">isBigInt</a></li><li data-type='method'><a href="Validator.html#.isBoolean">isBoolean</a></li><li data-type='method'><a href="Validator.html#.isEmptyObj">isEmptyObj</a></li><li data-type='method'><a href="Validator.html#.isEncoded">isEncoded</a></li><li data-type='method'><a href="Validator.html#.isFloat">isFloat</a></li><li data-type='method'><a href="Validator.html#.isFunction">isFunction</a></li><li data-type='method'><a href="Validator.html#.isInteger">isInteger</a></li><li data-type='method'><a href="Validator.html#.isNull">isNull</a></li><li data-type='method'><a href="Validator.html#.isNumber">isNumber</a></li><li data-type='method'><a href="Validator.html#.isObject">isObject</a></li><li data-type='method'><a href="Validator.html#.isOneDimensional">isOneDimensional</a></li><li data-type='method'><a href="Validator.html#.isString">isString</a></li><li data-type='method'><a href="Validator.html#.isSymbol">isSymbol</a></li><li data-type='method'><a href="Validator.html#.isType">isType</a></li><li data-type='method'><a href="Validator.html#.isUndefined">isUndefined</a></li><li data-type='method'><a href="Validator.html#.isValidType">isValidType</a></li></ul></li><li><a href="module-Various.AnsiColors.html">AnsiColors</a></li></ul><h3>Modules</h3><ul><li><a href="module-Arrays.html">Arrays</a><ul class='methods'><li data-type='method'><a href="module-Arrays.html#~accumulate">accumulate</a></li><li data-type='method'><a href="module-Arrays.html#~average">average</a></li><li data-type='method'><a href="module-Arrays.html#~chunk">chunk</a></li><li data-type='method'><a href="module-Arrays.html#~countOccurrences">countOccurrences</a></li><li data-type='method'><a href="module-Arrays.html#~firstIndex">firstIndex</a></li><li data-type='method'><a href="module-Arrays.html#~firstObjMatch">firstObjMatch</a></li><li data-type='method'><a href="module-Arrays.html#~generateObjectArray">generateObjectArray</a></li><li data-type='method'><a href="module-Arrays.html#~getIntersection">getIntersection</a></li><li data-type='method'><a href="module-Arrays.html#~indexOfMax">indexOfMax</a></li><li data-type='method'><a href="module-Arrays.html#~indexOfMin">indexOfMin</a></li><li data-type='method'><a href="module-Arrays.html#~indices">indices</a></li><li data-type='method'><a href="module-Arrays.html#~insertElements">insertElements</a></li><li data-type='method'><a href="module-Arrays.html#~isEqualArray">isEqualArray</a></li><li data-type='method'><a href="module-Arrays.html#~lastIndex">lastIndex</a></li><li data-type='method'><a href="module-Arrays.html#~partition">partition</a></li><li data-type='method'><a href="module-Arrays.html#~randomItem">randomItem</a></li><li data-type='method'><a href="module-Arrays.html#~range">range</a></li><li data-type='method'><a href="module-Arrays.html#~removeDuplicate">removeDuplicate</a></li><li data-type='method'><a href="module-Arrays.html#~removeDuplicatesArrObj">removeDuplicatesArrObj</a></li><li data-type='method'><a href="module-Arrays.html#~shuffle">shuffle</a></li><li data-type='method'><a href="module-Arrays.html#~swapItems">swapItems</a></li><li data-type='method'><a href="module-Arrays.html#~unionArrays">unionArrays</a></li></ul></li><li><a href="module-Numbers.html">Numbers</a><ul class='methods'><li data-type='method'><a href="module-Numbers.html#.arithmeticProgression">arithmeticProgression</a></li><li data-type='method'><a href="module-Numbers.html#.factorial">factorial</a></li><li data-type='method'><a href="module-Numbers.html#.fibonacci">fibonacci</a></li><li data-type='method'><a href="module-Numbers.html#.gcdMultiple">gcdMultiple</a></li><li data-type='method'><a href="module-Numbers.html#.geometricProgression">geometricProgression</a></li><li data-type='method'><a href="module-Numbers.html#.lcmMultiple">lcmMultiple</a></li><li data-type='method'><a href="module-Numbers.html#.logBase">logBase</a></li><li data-type='method'><a href="module-Numbers.html#.randomIntArrayInRange">randomIntArrayInRange</a></li><li data-type='method'><a href="module-Numbers.html#.randomNumberGenerator">randomNumberGenerator</a></li><li data-type='method'><a href="module-Numbers.html#.roundNumber">roundNumber</a></li><li data-type='method'><a href="module-Numbers.html#.toFixed">toFixed</a></li></ul></li><li><a href="module-Objects.html">Objects</a><ul class='methods'><li data-type='method'><a href="module-Objects.html#.combinedObjectWithArrays">combinedObjectWithArrays</a></li><li data-type='method'><a href="module-Objects.html#.commonKeys">commonKeys</a></li><li data-type='method'><a href="module-Objects.html#.countBy">countBy</a></li><li data-type='method'><a href="module-Objects.html#.getCommonKeys">getCommonKeys</a></li><li data-type='method'><a href="module-Objects.html#.getObjFromKey">getObjFromKey</a></li><li data-type='method'><a href="module-Objects.html#.groupBy">groupBy</a></li><li data-type='method'><a href="module-Objects.html#.isEqualObj">isEqualObj</a></li><li data-type='method'><a href="module-Objects.html#.maxBy">maxBy</a></li><li data-type='method'><a href="module-Objects.html#.minBy">minBy</a></li><li data-type='method'><a href="module-Objects.html#.pluck">pluck</a></li><li data-type='method'><a href="module-Objects.html#.removeArrayFromValues">removeArrayFromValues</a></li><li data-type='method'><a href="module-Objects.html#.removeDuplicatesByProperty">removeDuplicatesByProperty</a></li><li data-type='method'><a href="module-Objects.html#.removeDuplicatesFromValues">removeDuplicatesFromValues</a></li><li data-type='method'><a href="module-Objects.html#.removeNullUndefined">removeNullUndefined</a></li><li data-type='method'><a href="module-Objects.html#.removeObjectSafely">removeObjectSafely</a></li><li data-type='method'><a href="module-Objects.html#.renameKeys">renameKeys</a></li><li data-type='method'><a href="module-Objects.html#.sortBy">sortBy</a></li><li data-type='method'><a href="module-Objects.html#.sortObj">sortObj</a></li><li data-type='method'><a href="module-Objects.html#.splitObjInKeys">splitObjInKeys</a></li><li data-type='method'><a href="module-Objects.html#.toObject">toObject</a></li></ul></li><li><a href="module-String.html">String</a><ul class='methods'><li data-type='method'><a href="module-String.html#.bytesString">bytesString</a></li><li data-type='method'><a href="module-String.html#.camelToKebab">camelToKebab</a></li><li data-type='method'><a href="module-String.html#.capitalize">capitalize</a></li><li data-type='method'><a href="module-String.html#.characterCount">characterCount</a></li><li data-type='method'><a href="module-String.html#.cleanText">cleanText</a></li><li data-type='method'><a href="module-String.html#.concatWS">concatWS</a></li><li data-type='method'><a href="module-String.html#.countWords">countWords</a></li><li data-type='method'><a href="module-String.html#.decodeHtmlEntities">decodeHtmlEntities</a></li><li data-type='method'><a href="module-String.html#.decomposeUrl">decomposeUrl</a></li><li data-type='method'><a href="module-String.html#.ext">ext</a></li><li data-type='method'><a href="module-String.html#.generateString">generateString</a></li><li data-type='method'><a href="module-String.html#.isPalindrome">isPalindrome</a></li><li data-type='method'><a href="module-String.html#.kebabToCamel">kebabToCamel</a></li><li data-type='method'><a href="module-String.html#.mask">mask</a></li><li data-type='method'><a href="module-String.html#.prependNumbers">prependNumbers</a></li><li data-type='method'><a href="module-String.html#.removeAcents">removeAcents</a></li><li data-type='method'><a href="module-String.html#.removeEmptyLines">removeEmptyLines</a></li><li data-type='method'><a href="module-String.html#.replaceSpaces">replaceSpaces</a></li><li data-type='method'><a href="module-String.html#.slugify">slugify</a></li><li data-type='method'><a href="module-String.html#.sortLines">sortLines</a></li><li data-type='method'><a href="module-String.html#.toCamelCase">toCamelCase</a></li><li data-type='method'><a href="module-String.html#.toPascalCase">toPascalCase</a></li><li data-type='method'><a href="module-String.html#.trim">trim</a></li><li data-type='method'><a href="module-String.html#.truncate">truncate</a></li><li data-type='method'><a href="module-String.html#.upperCaseWords">upperCaseWords</a></li></ul></li><li><a href="module-Various.html">Various</a><ul class='methods'><li data-type='method'><a href="module-Various.html#.bubbleSort">bubbleSort</a></li><li data-type='method'><a href="module-Various.html#.bucketSort">bucketSort</a></li><li data-type='method'><a href="module-Various.html#.convertirMilisegundos">convertirMilisegundos</a></li><li data-type='method'><a href="module-Various.html#.decimalToHex">decimalToHex</a></li><li data-type='method'><a href="module-Various.html#.decodeJWT">decodeJWT</a></li><li data-type='method'><a href="module-Various.html#.generateShades">generateShades</a></li><li data-type='method'><a href="module-Various.html#.generateUniqueId">generateUniqueId</a></li><li data-type='method'><a href="module-Various.html#.getComplementaryColor">getComplementaryColor</a></li><li data-type='method'><a href="module-Various.html#.getSuplementaryColor">getSuplementaryColor</a></li><li data-type='method'><a href="module-Various.html#.getTypeOf">getTypeOf</a></li><li data-type='method'><a href="module-Various.html#.heapsort">heapsort</a></li><li data-type='method'><a href="module-Various.html#.hexToDecimal">hexToDecimal</a></li><li data-type='method'><a href="module-Various.html#.hexToHSL">hexToHSL</a></li><li data-type='method'><a href="module-Various.html#.hexToRgb">hexToRgb</a></li><li data-type='method'><a href="module-Various.html#.hslToHex">hslToHex</a></li><li data-type='method'><a href="module-Various.html#.hslToRgb">hslToRgb</a></li><li data-type='method'><a href="module-Various.html#.insertionSort">insertionSort</a></li><li data-type='method'><a href="module-Various.html#.measureAsyncFn">measureAsyncFn</a></li><li data-type='method'><a href="module-Various.html#.measureSyncFn">measureSyncFn</a></li><li data-type='method'><a href="module-Various.html#.mergeSort">mergeSort</a></li><li data-type='method'><a href="module-Various.html#.messageErrorSty1">messageErrorSty1</a></li><li data-type='method'><a href="module-Various.html#.messageErrorSty2">messageErrorSty2</a></li><li data-type='method'><a href="module-Various.html#.myDecodeURI">myDecodeURI</a></li><li data-type='method'><a href="module-Various.html#.myEncodeURI">myEncodeURI</a></li><li data-type='method'><a href="module-Various.html#.normalizeUrl">normalizeUrl</a></li><li data-type='method'><a href="module-Various.html#.parseJSONToString">parseJSONToString</a></li><li data-type='method'><a href="module-Various.html#.parseStringToJSON">parseStringToJSON</a></li><li data-type='method'><a href="module-Various.html#.pipe">pipe</a></li><li data-type='method'><a href="module-Various.html#.quickSort">quickSort</a></li><li data-type='method'><a href="module-Various.html#.randomBoolean">randomBoolean</a></li><li data-type='method'><a href="module-Various.html#.randomColorHex">randomColorHex</a></li><li data-type='method'><a href="module-Various.html#.rgbToHex">rgbToHex</a></li><li data-type='method'><a href="module-Various.html#.rgbToHsl">rgbToHsl</a></li><li data-type='method'><a href="module-Various.html#.selectionSort">selectionSort</a></li><li data-type='method'><a href="module-Various.html#.selectorContent">selectorContent</a></li><li data-type='method'><a href="module-Various.html#.timestampToutc">timestampToutc</a></li><li data-type='method'><a href="module-Various.html#.wait">wait</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">various-fn.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module Various
 */

/**
 * La función `wait` devuelve una promesa que se resuelve
 * después de esperar la cantidad de tiempo especificada
 * en milisegundos (valor por defecto 1 segundo).
 * Esto puede ser útil en situaciones donde necesitas pausar
 * la ejecución de cierto código durante un período de tiempo
 * específico, como en operaciones asíncronas o en situaciones
 * donde necesitas controlar el flujo de ejecución de manera temporal.
 * @param {number} ms=1000 Cantidad de milisegundos a esperar.
 * @returns {Promise} Retorna una promesa que no resuelve nada.
 * @example
 * console.log('Inicio del programa');
 *
 * wait(2000) // Espera 2 segundos (2000 milisegundos)
 *   .then(() => {
 *     console.log('Han pasado 2 segundos');
 *     return wait(3000); // Espera 3 segundos adicionales
 *   })
 *   .then(() => {
 *     console.log('Han pasado 5 segundos en total');
 *   });
 *
 * console.log('Fin del programa');
 * // Inicio del programa
 * // Fin del programa
 * // Han pasado 2 segundos
 * // Han pasado 5 segundos en total
 * @example
 * console.log('Inicio del programa');
 * await wait(); // Espera 1 segundo (1000 milisegundos)
 * console.log('Continua la ejecución del programa');
 */
export function wait(ms = 1000) {
    return new Promise((resuelve) => setTimeout(resuelve, ms))
}

/**
 * Permite decodificar un token JWT.
 * @param {string} token Token a decodificar.
 * @returns {Object} Retorna un objeto con los datos decodificados.
 * @example
 * decode(`
 *     eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
 *     eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0I
 *     joxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
 * `);
 *
 * // { "sub": "1234567890", "name": "John Doe", "iat": 1516239022 }
 */
export function decodeJWT(token) {
    return decodeURIComponent(atob(token.split('.')[1].replace('-', '+').replace('_', '/'))
        .split('')
        .map((c) => `%${('00' + c.charCodeAt(0).toString(16)).slice(-2)}`)
        .join(''));
}

/**
 * Permite obtener el tipo de una variable en un string.
 * @param obj Variable que se desea conocer el tipo.
 * @returns {string} Retorna un string con el nombre del tipo de variable.
 * @example
 * getTypeOf('hello world'); // String
 * getTypeOf(1000); // Number
 * getTypeOf(Infinity); // Number
 * getTypeOf(true); // Boolean
 * getTypeOf(Symbol()); // Symbol
 * getTypeOf(null); // Null
 * getTypeOf(undefined); // Undefined
 * getTypeOf({}); // Object
 * getTypeOf([]); // Array
 * getTypeOf(/[a-z]/g); // RegExp
 * getTypeOf(new Date(2021)); // Date
 * getTypeOf(new Error()); // Error
 * getTypeOf(function () {}); // Function
 * getTypeOf((a, b) => a + b); // Function
 * getTypeOf(async () => {}); // AsyncFunction
 * getTypeOf(document); // HTMLDocument
 */
export function getTypeOf(obj) {
    return Object.prototype.toString.call(obj).match(/\[object (.*)\]/)[1];
}

/**
 * Genera un ramdom color hex.
 * @returns {string} Retorna el color en hex.
 * @example
 * randomColorHex()
 * //#060c7c
 */
export function randomColorHex() {
    return `#${Math.random().toString(16).slice(2, 8).padEnd(6, '0')}`;
}

/**
 * Codificar una URL
 * @param url URL a codificar.
 * @returns {string} Retorna la URL codificada.
 */
export function myEncodeURI(url) {
    return encodeURIComponent(url)
        .replace(/!/g, '%21')
        .replace(/~/g, '%7E')
        .replace(/\*/g, '%2A')
        .replace(/'/g, '%27')
        .replace(/\(/g, '%28')
        .replace(/\)/g, '%29')
        .replace(/\+/g, '%20');
}

/**
 * Decodificar una URL
 * @param url URL a decodificar.
 * @returns {string} Retorna la URL decodificada.
 */
export function myDecodeURI(url) {
    return decodeURIComponent(url)
        .replace(/%21/g, '!')
        .replace(/%7E/g, '~')
        .replace(/%2A/g, '*')
        .replace(/%27/g, "'")
        .replace(/%28/g, '(')
        .replace(/%29/g, ')')
        .replace(/%20/g, '+');
}

/**
 * Función que implementa una tubería de funciones.
 * @param {...Function} functions - Funciones a ser ejecutadas en orden.
 * @returns {Function} - Función que ejecuta las funciones en secuencia.
 */
export function pipe(...functions) {
    return input =>
        functions.reduce((acc, fn) => fn(acc), input);
}

/**
 * Convierte un color en formato hexadecimal a HSL (Hue, Saturation, Lightness).
 * @param {string} hex - Color en formato hexadecimal.
 * @returns {Array} - Array con los valores HSL.
 */
export function hexToHSL(hex) {
    let r = 0, g = 0, b = 0; // Inicializa los valores de rojo, verde y azul.
    if (hex.length === 4) { // Verifica si el color es de 4 dígitos.
        r = parseInt(hex[1] + hex[1], 16); // Calcula el valor de rojo.
        g = parseInt(hex[2] + hex[2], 16); // Calcula el valor de verde.
        b = parseInt(hex[3] + hex[3], 16); // Calcula el valor de azul.
    } else if (hex.length === 7) { // Verifica si el color es de 7 dígitos.
        r = parseInt(hex[1] + hex[2], 16); // Calcula el valor de rojo.
        g = parseInt(hex[3] + hex[4], 16); // Calcula el valor de verde.
        b = parseInt(hex[5] + hex[6], 16); // Calcula el valor de azul.
    }
    r /= 255; // Normaliza el valor de rojo.
    g /= 255; // Normaliza el valor de verde.
    b /= 255; // Normaliza el valor de azul.
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h = 0, s = 0, l = (max + min) / 2; // Calcula los valores de máximo, mínimo, matiz, saturación y luminosidad.
    if (max !== min) { // Verifica si el color no es una escala de grises.
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g &lt; b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return [h, s, l]; // Devuelve el array con los valores HSL.
}

/**
 * Convierte un color de formato HSL a formato hexadecimal.
 * @param {number} h - Matiz (hue) en grados.
 * @param {number} s - Saturación (saturation) en porcentaje.
 * @param {number} l - Luminosidad (lightness) en porcentaje.
 * @returns {string} - Color en formato hexadecimal.
 */
export function hslToHex(h, s, l) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l; // Si la saturación es 0, el color es acromático.
    } else {
        const hue2rgb = (p, q, t) => {
            if (t &lt; 0) t += 1;
            if (t > 1) t -= 1;
            if (t &lt; 1 / 6) return p + (q - p) * 6 * t;
            if (t &lt; 1 / 2) return q;
            if (t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        let q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    r = Math.round(r * 255);
    g = Math.round(g * 255);
    b = Math.round(b * 255);

    return "#" + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);
}

/**
 * Función para obtener el color complementario de un color en formato hexadecimal.
 * @param {string} hex - Color en formato hexadecimal.
 * @returns {string} - Color complementario en formato hexadecimal.
 */
export function getComplementaryColor(hex) {
    let [h, s, l] = hexToHSL(hex);
    h = (h + 0.5) % 1.0; // Sumar 180 grados al matiz para obtener el color complementario
    return hslToHex(h, s, l);
}

/**
 * Convierte un color hexadecimal a RGB.
 * @param {string} hex - Color hexadecimal a convertir.
 * @returns {Array} - Arreglo con los valores RGB.
 */
export function hexToRgb(hex) {
    // Eliminar el signo # si está presente
    hex = hex.replace(/^#/, '');

    // Convertir el color hexadecimal a RGB
    let bigint = parseInt(hex, 16);
    let r = (bigint >> 16) &amp; 255; // Extraer el componente rojo
    let g = (bigint >> 8) &amp; 255; // Extraer el componente verde
    let b = bigint &amp; 255; // Extraer el componente azul

    return [r, g, b]; // Devolver un arreglo con los valores RGB
}

/**
 * Convierte los valores RGB a hexadecimal.
 * @param {number} r - Valor de rojo (0-255).
 * @param {number} g - Valor de verde (0-255).
 * @param {number} b - Valor de azul (0-255).
 * @returns {string} Representación hexadecimal del color RGB.
 */
export function rgbToHex(r, g, b) {
    // Se realiza la conversión de los valores RGB a su representación hexadecimal
    return "#" + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1).toUpperCase();
}

/**
 * Convierte un color RGB a HSL (Hue, Saturation, Lightness).
 * @param {number} r - Valor de rojo (0-255).
 * @param {number} g - Valor de verde (0-255).
 * @param {number} b - Valor de azul (0-255).
 * @returns {Array} - Array con los valores de HSL.
 */
export function rgbToHsl(r, g, b) {
    // Normalizar los valores RGB al rango 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    let max = Math.max(r, g, b);
    let min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // Si el máximo y el mínimo son iguales, el color es gris
    } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g &lt; b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }

    return [h * 360, s, l]; // Devuelve los valores de HSL
}

/**
 * Convierte un color de formato HSL a RGB.
 * @param {number} h - Matiz (hue) en grados.
 * @param {number} s - Saturación (saturation) como un valor entre 0 y 1.
 * @param {number} l - Luminosidad (lightness) como un valor entre 0 y 1.
 * @returns {Array} - Un arreglo con los valores RGB resultantes.
 */
export function hslToRgb(h, s, l) {
    let r, g, b;

    if (s === 0) {
        // Si la saturación es 0, el color es una escala de grises
        r = g = b = l;
    } else {
        function hue2rgb(p, q, t) {
            if (t &lt; 0) t += 1;
            if (t > 1) t -= 1;
            if (t &lt; 1 / 6) return p + (q - p) * 6 * t;
            if (t &lt; 1 / 3) return q;
            if (t &lt; 1 / 2) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }

        let q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        h /= 360;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r * 255, g * 255, b * 255];
}

/**
 * Función para obtener el color suplementario de un color hexadecimal.
 * @param {string} hex - Color hexadecimal.
 * @param {number} angle=25 - Ángulo para calcular el color suplementario.
 * @returns {string} Color hexadecimal suplementario.
 */
export function getSuplementaryColor(hex, angle = 25) {
    // Convertir el color hexadecimal a RGB
    let [r, g, b] = hexToRgb(hex);

    // Convertir RGB a HSL
    let [h, s, l] = rgbToHsl(r, g, b);

    // Calcular el nuevo tono (H) sumando el ángulo y asegurándose de que esté en el rango [0, 360)
    h = (h + angle) % 360;
    if (h &lt; 0) h += 360;

    // Convertir el nuevo HSL a RGB
    let [adjR, adjG, adjB] = hslToRgb(h, s, l);

    // Convertir el nuevo RGB a hexadecimal y devolverlo
    return rgbToHex(Math.round(adjR), Math.round(adjG), Math.round(adjB));
}

/**
 * Función para generar una serie de tonos a partir de un color hexadecimal dado.
 * @param {string} hex - Color hexadecimal base.
 * @param {number} numOfShades - Número de tonos a generar (por defecto 10).
 * @param {number} percentageDifference - Diferencia porcentual entre tonos adyacentes (por defecto 10).
 * @returns {Array} - Arreglo con los tonos generados.
 */
export function generateShades(hex, numOfShades = 10, percentageDifference = 10) {
    // Convertir el color hexadecimal a RGB
    let [r, g, b] = hexToRgb(hex);
    let shades = [];

    // Generar los tonos
    for (let i = 0; i &lt; numOfShades; i++) {
        // Calcular el factor de ajuste para el tono actual
        let factor = 1 + (percentageDifference / 100) * (i - Math.floor(numOfShades / 2));
        // Calcular los componentes RGB del tono
        let shadeR = Math.min(255, Math.max(0, Math.round(r * factor)));
        let shadeG = Math.min(255, Math.max(0, Math.round(g * factor)));
        let shadeB = Math.min(255, Math.max(0, Math.round(b * factor)));
        // Convertir los componentes RGB a color hexadecimal y agregarlo al arreglo de tonos
        shades.push(rgbToHex(shadeR, shadeG, shadeB));
    }

    return shades;
}

/**
 * Función que convierte una cadena en formato clave-valor a un objeto JSON.
 * @param {string} str - La cadena en formato clave-valor a convertir.
 * @param {string} separatorPair - El separador entre pares clave-valor (por defecto ';').
 * @param {string} separatorValue - El separador entre clave y valor (por defecto '=').
 * @returns {object} - Objeto JSON con las claves y valores extraídos de la cadena.
 */
export function parseStringToJSON(str, separatorPair = ';', separatorValue = '=') {
    const result = {};
    const pairs = str.split(separatorPair).filter(Boolean).map(pair => pair.trim()); // Divide la cadena en pares clave-valor y elimina espacios en blanco.
    pairs.forEach(pair => {
        // Divide el par en clave y valor.
        const sep = pair.indexOf(separatorValue);
        const key = pair.substring(0, sep);
        const value = pair.substring(sep + 1);
        let parsedValue;
        if (value === undefined) { // Comprueba si el valor es indefinido.
            parsedValue = '';
        } else if (!isNaN(Number(value)) &amp;&amp; value.trim() !== '') { // Verifica si el valor es numérico.
            parsedValue = Number(value); // Convierte el valor a número.
        } else if (['true', 'false'].includes(value.toLowerCase())) { // Comprueba si el valor es booleano.
            parsedValue = value.toLowerCase() === 'true'; // Convierte el valor booleano a booleano.
        } else {
            parsedValue = value; // Asigna el valor como cadena.
        }
        result[key] = parsedValue; // Asigna el valor parseado a la clave correspondiente en el objeto JSON.
    });
    return result; // Devuelve el objeto JSON resultante.
}

/**
 * Función que convierte un objeto JSON en una cadena en formato clave-valor.
 * @param {object} obj - El objeto JSON a convertir.
 * @param {string} separatorPair - El separador entre pares clave-valor (por defecto ';').
 * @param {string} separatorValue - El separador entre clave y valor (por defecto '=').
 * @returns {string} - Cadena en formato clave-valor.
 */
export function parseJSONToString(obj, separatorPair = '; ', separatorValue = '=') {
    return Object.entries(obj)
        .map(([key, value]) => {
            let stringValue;

            if (typeof value === 'boolean') {
                stringValue = value ? 'true' : 'false'; // Convierte booleano a cadena.
            } else if (value === undefined || value === null) {
                stringValue = ''; // Convierte indefinido o nulo a cadena vacía.
            } else {
                stringValue = String(value); // Convierte otros tipos a cadena.
            }

            return `${key}${separatorValue}${stringValue}`; // Forma el par clave-valor.
        })
        .join(separatorPair); // Une todos los pares con el separador especificado.
}


/**
 * Función para ordenar un arreglo utilizando el algoritmo de Quick Sort.
 * @param {Array} arr - El arreglo que se desea ordenar.
 * @returns {Array} - El arreglo ordenado.
 * @example
 * quickSort([1, 6, 1, 5, 3, 2, 1, 4]);
 * // [1, 1, 1, 2, 3, 4, 5, 6]
 */
export function quickSort(arr) {
    // Se crea una copia del arreglo para no modificar el original
    const a = [...arr];

    // Caso base: si el arreglo tiene menos de 2 elementos, se devuelve el arreglo
    if (a.length &lt; 2) return a;

    // Se calcula el índice del pivote
    const pivotIndex = Math.floor(arr.length / 2);
    const pivot = a[pivotIndex]; // Se obtiene el valor del pivote

    // Se separan los elementos menores y mayores que el pivote
    const [lo, hi] = a.reduce(
        (acc, val, i) => {
            if (val &lt; pivot || (val === pivot &amp;&amp; i != pivotIndex)) {
                acc[0].push(val); // Se añade al arreglo de menores
            } else if (val > pivot) {
                acc[1].push(val); // Se añade al arreglo de mayores
            }
            return acc;
        },
        [[], []]
    );

    // Se aplica recursivamente quickSort a los subarreglos menores y mayores, y se concatena con el pivote
    return [...quickSort(lo), pivot, ...quickSort(hi)];
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo Merge Sort.
 * @param {Array} arr - El arreglo a ordenar.
 * @returns {Array} - El arreglo ordenado.
 * @example
 * mergeSort([5, 1, 4, 2, 3]);
 * // [1, 2, 3, 4, 5]
 */
export function mergeSort(arr) {
    // Verificar si el arreglo tiene menos de 2 elementos
    if (arr.length &lt; 2) return arr;

    // Calcular el punto medio del arreglo
    const mid = Math.floor(arr.length / 2);

    // Dividir el arreglo en dos partes y llamar recursivamente a mergeSort
    const l = mergeSort(arr.slice(0, mid));
    const r = mergeSort(arr.slice(mid, arr.length));

    // Combinar y ordenar las dos partes del arreglo
    return Array.from({length: l.length + r.length}, () => {
        // Verificar si alguna de las partes ya no tiene elementos
        if (!l.length) return r.shift();
        else if (!r.length) return l.shift();
        // Comparar y combinar los elementos de las dos partes
        else return l[0] > r[0] ? r.shift() : l.shift();
    });
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo de heapsort.
 * @param {Array} arr - Arreglo a ordenar.
 * @returns {Array} - Arreglo ordenado.
 * @example
 * heapsort([6, 3, 4, 1]);
 * // [1, 3, 4, 6]
 */
export function heapsort(arr) {
    // Se crea una copia del arreglo para no modificar el original
    const a = [...arr];
    let l = a.length;

    // Función para convertir el arreglo en un heap
    const heapify = (a, i) => {
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        let max = i;
        if (left &lt; l &amp;&amp; a[left] > a[max]) max = left;
        if (right &lt; l &amp;&amp; a[right] > a[max]) max = right;
        if (max !== i) {
            [a[max], a[i]] = [a[i], a[max]];
            heapify(a, max);
        }
    };

    // Se convierte el arreglo en un heap
    for (let i = Math.floor(l / 2); i >= 0; i -= 1) heapify(a, i);

    // Se ordena el heap
    for (let i = a.length - 1; i > 0; i--) {
        [a[0], a[i]] = [a[i], a[0]];
        l--;
        heapify(a, 0);
    }
    return a;
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo de Bubble Sort.
 * @param {Array} arr - El arreglo a ordenar.
 * @returns {Array} - El arreglo ordenado.
 * @example
 * bubbleSort([2, 1, 4, 3]);
 * // [1, 2, 3, 4]
 */
export function bubbleSort(arr) {
    let swapped = false; // Variable para controlar si se realizó un intercambio en la iteración actual.
    const a = [...arr]; // Se crea una copia del arreglo para no modificar el original.
    for (let i = 1; i &lt; a.length; i++) { // Bucle externo para recorrer el arreglo.
        swapped = false; // Se reinicia la variable de intercambio en cada iteración.
        for (let j = 0; j &lt; a.length - i; j++) { // Bucle interno para comparar elementos y realizar intercambios.
            if (a[j + 1] &lt; a[j]) { // Si el elemento siguiente es menor que el actual, se intercambian.
                [a[j], a[j + 1]] = [a[j + 1], a[j]]; // Intercambio de elementos.
                swapped = true; // Se marca que se realizó un intercambio.
            }
        }
        if (!swapped) return a; // Si no se realizó ningún intercambio en la iteración, el arreglo está ordenado.
    }
    return a; // Se devuelve el arreglo ordenado.
}

/**
 * Función que implementa el algoritmo de ordenamiento por inserción.
 * @param {Array} arr - El arreglo que se va a ordenar.
 * @returns {Array} - El arreglo ordenado.
 */
export function insertionSort(arr) {
    return arr.reduce((acc, x) => {
        if (!acc.length) return [x]; // Si el arreglo está vacío, se agrega el primer elemento.
        acc.some((y, j) => {
            if (x &lt;= y) {
                acc.splice(j, 0, x); // Se inserta el elemento en la posición correcta.
                return true;
            }
            if (x > y &amp;&amp; j === acc.length - 1) {
                acc.splice(j + 1, 0, x); // Se inserta el elemento al final del arreglo.
                return true;
            }
            return false;
        });
        return acc;
    }, []);
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo de Selection Sort.
 * @param {Array} arr - El arreglo que se desea ordenar.
 * @returns {Array} - El arreglo ordenado.
 */
export function selectionSort(arr) {
    // Se crea una copia del arreglo para no modificar el original
    const a = [...arr];

    // Iteración sobre el arreglo
    for (let i = 0; i &lt; a.length; i++) {
        // Encontrar el índice del elemento mínimo en el subarreglo restante
        const min = a
            .slice(i + 1)
            .reduce((acc, val, j) => (val &lt; a[acc] ? j + i + 1 : acc), i);

        // Intercambiar elementos si es necesario
        if (min !== i) [a[i], a[min]] = [a[min], a[i]];
    }

    // Devolver el arreglo ordenado
    return a;
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo Bucket Sort.
 * @param {Array} arr - Arreglo a ordenar.
 * @param {number} size - Tamaño de los buckets (por defecto es 5).
 * @returns {Array} - Arreglo ordenado.
 */
export function bucketSort(arr, size = 5) {
    // Encontrar el valor mínimo y máximo en el arreglo
    const min = Math.min(...arr);
    const max = Math.max(...arr);

    // Crear los buckets basados en el tamaño y rango de valores
    const buckets = Array.from(
        {length: Math.floor((max - min) / size) + 1},
        () => []
    );

    // Colocar cada elemento del arreglo en el bucket correspondiente
    arr.forEach(val => {
        buckets[Math.floor((val - min) / size)].push(val);
    });

    // Ordenar cada bucket y combinarlos en un solo arreglo ordenado
    return buckets.reduce((acc, b) => [...acc, ...b.sort((a, b) => a - b)], []);
}

/**
 * Convierte un número decimal a su equivalente en hexadecimal.
 * @param {number} dec - Número decimal a convertir.
 * @returns {string} - Número hexadecimal resultante.
 * @example
 * console.log(decimalToHex(0)); // '0'
 * console.log(decimalToHex(255)); // 'ff'
 */
export function decimalToHex(dec) {
    // Utiliza el método toString con base 16 para convertir el número decimal a hexadecimal.
    return dec.toString(16);
}

/**
 * Convierte un número hexadecimal en decimal.
 * @param {string} hex - El número hexadecimal a convertir.
 * @returns {number} El número decimal convertido.
 * @example
 * console.log(hexToDecimal('0')); // 0
 * console.log(hexToDecimal('ff')); // 255
 */
export function hexToDecimal(hex) {
    // Utiliza la función parseInt() con base 16 para convertir el número hexadecimal en decimal.
    return parseInt(hex, 16);
}

/**
 * Función que devuelve un valor booleano aleatorio.
 * @returns {boolean} - Valor booleano aleatorio.
 */
export function randomBoolean() {
    return Math.random() >= 0.5; // Devuelve true si el número aleatorio es mayor o igual a 0.5, de lo contrario, false.
}

/**
 * Genera un ID único basado en un prefijo dado.
 * @param {string} prefix - El prefijo que se añadirá al ID único.
 * @returns {string} - Un ID único en formato 'prefijo-XXXXXXX'.
 */
export function generateUniqueId(prefix) {
    // Genera un número aleatorio y lo convierte a base 36 (alfanumérico)
    // Luego, se extraen los caracteres del índice 2 al 9 para formar la parte única del ID
    return `${prefix}-${Math.random().toString(36).substring(2, 9)}`;
}

/**
 * Convierte un timestamp en segundos a una cadena de fecha en formato UTC.
 * @param {number} timestampSeconds - El timestamp en segundos que se desea convertir.
 * @returns {string|number} - La fecha en formato UTC o el valor original si no es un número válido.
 */
export function timestampToutc(timestampSeconds) {
    // Verifica si el valor proporcionado es un número válido
    if (!/[\d\.]+/.test(String(timestampSeconds))) {
        // Si no es un número válido, retorna el valor original
        return timestampSeconds;
    }
    // Convierte el timestamp de segundos a milisegundos
    const timestampMilliseconds = timestampSeconds * 1000;
    // Crea un objeto Date a partir del timestamp en milisegundos
    const date = new Date(timestampMilliseconds);
    // Retorna la representación de la fecha en formato UTC
    return date.toUTCString();
}

/**
 * Función para mostrar un mensaje de error con estilo personalizado.
 * @param {string} message - El mensaje que se mostrará en la consola.
 * @param {string} [error=''] - Mensaje de error adicional (opcional).
 * @param {string} [c='yellow'] - Color del texto (opcional).
 * @param {string} [bg='black'] - Color de fondo (opcional).
 */
export function messageErrorSty1(message, error = '', c = 'yellow', bg = 'black') {
    // Imprime el mensaje en la consola con estilos CSS personalizados
    console.log(
        `%c ${message} \n`, // Formato del mensaje con estilo
        `color: ${c}; background: ${bg};`, // Estilos CSS aplicados al mensaje
        error // Mensaje de error adicional
    );
}

/**
 * Muestra un mensaje de error estilizado en la consola.
 *
 * @param {string} message - El mensaje de error a mostrar.
 * @param {string} url - La URL relacionada con el error.
 * @param {number} attempt - El número actual de intentos.
 * @param {number} retries - El número total de reintentos permitidos.
 * @param {string} [error=''] - Mensaje de error adicional (opcional).
 * @param {string} [c1='red'] - Color del texto principal (opcional).
 * @param {string} [c2='yellow'] - Color del texto secundario (opcional).
 * @param {string} [bg='black'] - Color de fondo del mensaje (opcional).
 */
export function messageErrorSty2(message, url, attempt, retries, error = '', c1 = 'red', c2 = 'yellow', bg = 'black') {
    // Imprime el mensaje de error en la consola con estilos personalizados
    console.log(
        // Formato del mensaje con estilos CSS
        `%c${message}\nURL: %c ${url} \n%cIntento: %c ${attempt + 1}/${retries} %c \n%c${error}`,
        // Estilo para el mensaje principal
        `color: ${c1};`,
        // Estilo para la URL
        `color: ${c2}; background: ${bg};`,
        // Estilo para el intento
        `color: ${c1};`,
        // Estilo para el número de intentos
        `color: ${c2}; background: ${bg};`,
        // Estilo para el separador
        '',
        // Estilo para el mensaje de error adicional
        `color: ${c1};`
    );
}

/**
 * Normaliza una URL dada, asegurando que use el protocolo HTTPS.
 * @param {string} url - La URL que se desea normalizar.
 * @param {string} origin - El origen que se usará si la URL es relativa.
 * @returns {string} - La URL normalizada.
 */
export function normalizeUrl(url, origin) {
    // Verifica si la URL comienza con "//", lo que indica un protocolo implícito.
    if (url.startsWith("//")) {
        // Agrega "https:" al inicio de la URL y la codifica.
        return encodeURI(`https:${url}`);
    }
    // Verifica si la URL comienza con "http://".
    if (url.startsWith("http://")) {
        // Reemplaza "http://" por "https://" y codifica la URL.
        return encodeURI(url.replace("http://", "https://"));
    }
    // Verifica si la URL ya comienza con "https://".
    if (url.startsWith("https://")) {
        // Si ya es HTTPS, simplemente la codifica.
        return encodeURI(url);
    }
    // Verifica si la URL es un ancla o la raíz.
    if (url === "#" || url === "/") {
        // Devuelve el origen si la URL es un ancla o la raíz.
        return origin;
    }
    // Si la URL comienza con "/", se considera relativa.
    return url.startsWith("/")
        // Codifica la URL concatenando el origen y la URL relativa.
        ? encodeURI(`${origin}${url}`)
        // Codifica la URL concatenando el origen y la URL, añadiendo una barra.
        : encodeURI(`${origin}/${url}`);
}

/**
 * Obtiene el contenido de un selector usando Cheerio, con soporte para múltiples selectores y valores por defecto.
 * @param {Object} $ - La instancia de Cheerio.
 * @param {string|string[]} selectors - Selector(es) de Cheerio. Puede ser un solo selector o un array de selectores.
 *        Si es un array, se intenta encontrar el contenido con cada uno en orden.
 * @param {*} defaultValue - Valor por defecto a retornar si no se encuentra ningún resultado válido.
 * @param {boolean} [isArr=false] - Si es true, retorna un array de nodos encontrados por el selector.
 * @param {boolean} [txt=true] - Si es true, retorna el texto del elemento seleccionado; si es false, retorna el HTML.
 * @returns {*} - El contenido encontrado o el valor por defecto.
 */
export function selectorContent($, selectors, defaultValue, isArr = false, txt = true) {
    // Función auxiliar: Verifica si un valor no está vacío (null, undefined, cadena vacía, 0 o array vacío).
    const isNotEmpty = (v) => ![null, undefined, '', 0].includes(v) &amp;&amp; v.length > 0;
    /**
     * Función auxiliar: Obtiene el contenido del selector.
     * @param {Object} $ - Instancia de Cheerio.
     * @param {boolean} a - Indica si se debe retornar un array de nodos.
     * @param {string} s - Selector de Cheerio.
     * @param {boolean} t - Indica si se debe obtener el texto (true) o el HTML (false).
     * @returns {*} - Texto, HTML o array de nodos dependiendo de los parámetros.
     */
    const prodOrTxt = ($, a, s, t) =>
        a
            ? [...$(s)] // Retorna un array de nodos si 'a' es true.
            : t
                ? $(s).first().text().replace(/\s\s+/g, ' ').trim() // Retorna el texto, limpiando saltos de línea.
                : $(s).first().html(); // Retorna el HTML del primer elemento encontrado.

    let result = defaultValue; // Inicializa el resultado con el valor por defecto.
    if (Array.isArray(selectors)) {
        // Si los selectores son un array, itera sobre ellos.
        for (const selector of selectors) {
            if (Array.isArray(selector)) {
                // Si el selector es un array, se espera que sea del tipo [selector, atributo].
                result = $(selector[0]).attr(selector[1]);
            } else {
                // Si no es un array, obtiene el contenido usando prodOrTxt.
                result = prodOrTxt($, isArr, selector, txt);
            }
            // Si el resultado no está vacío, termina la iteración.
            if (isNotEmpty(result)) break;
        }
    } else {
        // Si los selectores no son un array, obtiene el contenido directamente.
        result = prodOrTxt($, isArr, selectors, txt);
    }
    // Retorna el resultado si no está vacío; de lo contrario, retorna el valor por defecto.
    return isNotEmpty(result) ? result : defaultValue;
}

/**
 * Función que mide el tiempo de ejecución de una función sincrónica.
 * @param {Function} callBack - La función a medir.
 * @param {...*} args - Los argumentos a pasar a la función.
 * @returns {*} El resultado de la función callBack.
 */
export function measureSyncFn(callBack, ...args) {
    // Verifica si el argumento callBack es una función
    if (typeof callBack !== 'function') {
        throw new TypeError('El argumento callBack debe ser una función.');
    }
    // Marca el inicio del proceso
    performance.mark('inicioProceso');
    // Ejecuta la función callBack con los argumentos proporcionados
    const result = callBack(...args);
    // Marca el fin del proceso
    performance.mark('finProceso');
    // Mide la duración del proceso entre las marcas de inicio y fin
    performance.measure('duraciónProceso', 'inicioProceso', 'finProceso');
    // Obtiene las entradas de medición de rendimiento
    const medidas = performance.getEntriesByType('measure');
    // Verifica si no se registraron medidas de rendimiento
    if (medidas.length === 0) {
        console.log('%cNo se registraron medidas de rendimiento.', 'color: red;');
        return null;
    }
    // Convierte la duración de milisegundos a un formato legible
    const tiempo = convertirMilisegundos(medidas[0].duration);
    // Muestra el tiempo de ejecución en la consola
    console.log('%cEl proceso ha durado: %s', 'color: yellow; background: black;',
        `${String(tiempo.horas).padStart(2, '0')}h ${String(tiempo.minutos).padStart(2, '0')}m ${String(tiempo.segundos).padStart(2, '0')}s || ${medidas[0].duration}ms`);
    // Retorna el resultado de la función callBack
    return result;
}

/**
 * Función que mide el tiempo de ejecución de una función asíncrona.
 * @param {Function} callBack - La función a medir.
 * @param {...*} args - Los argumentos a pasar a la función.
 * @returns {Promise&lt;*>} El resultado de la función callBack.
 */
export async function measureAsyncFn(callBack, ...args) {
    // Verifica si el argumento callBack es una función
    if (typeof callBack !== 'function') {
        throw new TypeError('El argumento callBack debe ser una función.');
    }
    // Marca el inicio del proceso
    performance.mark('inicioProceso');
    // Ejecuta la función callBack de manera asíncrona con los argumentos proporcionados
    const result = await callBack(...args);
    // Marca el fin del proceso
    performance.mark('finProceso');
    // Mide la duración del proceso entre las marcas de inicio y fin
    performance.measure('duraciónProceso', 'inicioProceso', 'finProceso');
    // Obtiene las entradas de medición de rendimiento
    const medidas = performance.getEntriesByType('measure');
    // Verifica si no se registraron medidas de rendimiento
    if (medidas.length === 0) {
        console.log('%cNo se registraron medidas de rendimiento.', 'color: red;');
        return null;
    }
    // Convierte la duración de milisegundos a un formato legible
    const tiempo = convertirMilisegundos(medidas[0].duration);
    // Muestra el tiempo de ejecución en la consola
    console.log('%cEl proceso ha durado: %s', 'color: yellow; background: black;',
        `${String(tiempo.horas).padStart(2, '0')}h ${String(tiempo.minutos).padStart(2, '0')}m ${String(tiempo.segundos).padStart(2, '0')}s || ${medidas[0].duration}ms`);
    // Retorna el resultado de la función callBack
    return result;
}

/**
 * Convierte milisegundos a un objeto que contiene horas, minutos, segundos y milisegundos.
 * @param {number} milisegundos - La cantidad de milisegundos a convertir.
 * @returns {Object} Un objeto con horas, minutos, segundos y milisegundos.
 */
export function convertirMilisegundos(milisegundos) {
    // Calcula el total de segundos a partir de los milisegundos
    const segundosTotales = Math.floor(milisegundos / 1000);
    // Calcula las horas a partir de los segundos totales
    const horas = Math.floor(segundosTotales / 3600);
    // Calcula los minutos restantes
    const minutos = Math.floor((segundosTotales % 3600) / 60);
    // Calcula los segundos restantes
    const segundos = segundosTotales % 60;
    // Retorna un objeto con las conversiones
    return {
        horas,
        minutos,
        segundos,
        milisegundos
    };
}

/**
 * Clase que define colores ANSI para la salida en consola.
 *
 * Esta clase proporciona códigos ANSI para aplicar estilos de texto
 * y colores de fondo en la salida de consola.
 */
export class AnsiColors {
    /**
     * Código ANSI para restablecer el formato de color a su estado original.
     * @type {string}
     */
    static RESET = '\x1b[0m';
    /**
     * Código ANSI para aplicar negrita al texto.
     * @type {string}
     */
    static BOLD = '\x1b[1m';
    /**
     * Código ANSI para subrayar el texto.
     * @type {string}
     */
    static UNDERLINE = '\x1b[4m';
    /**
     * Código ANSI para invertir los colores de fondo y texto.
     * @type {string}
     */
    static INVERT = '\x1b[7m';
    /**
     * Código ANSI para establecer el color negro en el texto.
     * @type {string}
     */
    static BLACK = '\x1b[30m';
    /**
     * Código ANSI para establecer el color rojo en el texto.
     * @type {string}
     */
    static RED = '\x1b[31m';
    /**
     * Código ANSI para establecer el color verde en el texto.
     * @type {string}
     */
    static GREEN = '\x1b[32m';
    /**
     * Código ANSI para establecer el color amarillo en el texto.
     * @type {string}
     */
    static YELLOW = '\x1b[33m';
    /**
     * Código ANSI para establecer el color azul en el texto.
     * @type {string}
     */
    static BLUE = '\x1b[34m';
    /**
     * Código ANSI para establecer el color magenta en el texto.
     * @type {string}
     */
    static MAGENTA = '\x1b[35m';
    /**
     * Código ANSI para establecer el color cian en el texto.
     * @type {string}
     */
    static CYAN = '\x1b[36m';
    /**
     * Código ANSI para establecer el color blanco en el texto.
     * @type {string}
     */
    static WHITE = '\x1b[37m';
    /**
     * Código ANSI para establecer el color negro en el fondo.
     * @type {string}
     */
    static BG_BLACK = '\x1b[40m';
    /**
     * Código ANSI para establecer el color rojo en el fondo.
     * @type {string}
     */
    static BG_RED = '\x1b[41m';
    /**
     * Código ANSI para establecer el color verde en el fondo.
     * @type {string}
     */
    static BG_GREEN = '\x1b[42m';
    /**
     * Código ANSI para establecer el color amarillo en el fondo.
     * @type {string}
     */
    static BG_YELLOW = '\x1b[43m';
    /**
     * Código ANSI para establecer el color azul en el fondo.
     * @type {string}
     */
    static BG_BLUE = '\x1b[44m';
    /**
     * Código ANSI para establecer el color magenta en el fondo.
     * @type {string}
     */
    static BG_MAGENTA = '\x1b[45m';
    /**
     * Código ANSI para establecer el color cian en el fondo.
     * @type {string}
     */
    static BG_CYAN = '\x1b[46m';
    /**
     * Código ANSI para establecer el color blanco en el fondo.
     * @type {string}
     */
    static BG_WHITE = '\x1b[47m';
}
</code></pre>
        </article>
    </section>





    
</div>

<br class="clear">

<footer>
    Hecho con <small>❤</small> por <a
        href="https://github.com/xdany01">@xdany01</a> usando la plantilla de <a
        href="https://github.com/clenemt/docdash">docdash</a>.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
