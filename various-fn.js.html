<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>various-fn.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnsiColors.html">AnsiColors</a></li><li><a href="ArithmeticException.html">ArithmeticException</a></li><li><a href="Exception.html">Exception</a></li><li><a href="GestorBuffersImagen.html">GestorBuffersImagen</a><ul class='methods'><li data-type='method'><a href="GestorBuffersImagen.html#agregar">agregar</a></li><li data-type='method'><a href="GestorBuffersImagen.html#guardarTodos">guardarTodos</a></li><li data-type='method'><a href="GestorBuffersImagen.html#listar">listar</a></li><li data-type='method'><a href="GestorBuffersImagen.html#obtener">obtener</a></li></ul></li><li><a href="HttpClientException.html">HttpClientException</a></li><li><a href="IllegalArgumentException.html">IllegalArgumentException</a></li><li><a href="IllegalFormatException.html">IllegalFormatException</a></li><li><a href="IndexOutOfBoundsException.html">IndexOutOfBoundsException</a></li><li><a href="Logger.html">Logger</a><ul class='methods'><li data-type='method'><a href="Logger.html#.error">error</a></li><li data-type='method'><a href="Logger.html#.info">info</a></li><li data-type='method'><a href="Logger.html#.log">log</a></li><li data-type='method'><a href="Logger.html#.success">success</a></li><li data-type='method'><a href="Logger.html#.warning">warning</a></li></ul></li><li><a href="NullPointerException.html">NullPointerException</a></li><li><a href="OutOfMemoryException.html">OutOfMemoryException</a></li><li><a href="SelectorContent.html">SelectorContent</a><ul class='methods'><li data-type='method'><a href="SelectorContent.html#elementsToArray">elementsToArray</a></li><li data-type='method'><a href="SelectorContent.html#getAttributeValue">getAttributeValue</a></li><li data-type='method'><a href="SelectorContent.html#getCleanText">getCleanText</a></li><li data-type='method'><a href="SelectorContent.html#getContent">getContent</a></li><li data-type='method'><a href="SelectorContent.html#getElements">getElements</a></li><li data-type='method'><a href="SelectorContent.html#getHtml">getHtml</a></li><li data-type='method'><a href="SelectorContent.html#getValueOrDefault">getValueOrDefault</a></li><li data-type='method'><a href="SelectorContent.html#processMultipleSelectors">processMultipleSelectors</a></li><li data-type='method'><a href="SelectorContent.html#processSelector">processSelector</a></li><li data-type='method'><a href="SelectorContent.html#processSelectors">processSelectors</a></li><li data-type='method'><a href="SelectorContent.html#processSingleSelector">processSingleSelector</a></li></ul></li><li><a href="Sequence.html">Sequence</a><ul class='methods'><li data-type='method'><a href="Sequence.html#next">next</a></li></ul></li><li><a href="Task.html">Task</a><ul class='methods'><li data-type='method'><a href="Task.html#catch">catch</a></li><li data-type='method'><a href="Task.html#map">map</a></li><li data-type='method'><a href="Task.html#run">run</a></li><li data-type='method'><a href="Task.html#tap">tap</a></li><li data-type='method'><a href="Task.html#.from">from</a></li></ul></li><li><a href="TypeCastException.html">TypeCastException</a></li><li><a href="TypeMismatchException.html">TypeMismatchException</a></li><li><a href="UnsupportedOperationException.html">UnsupportedOperationException</a></li><li><a href="UserAgentRotatorFn.html">UserAgentRotatorFn</a><ul class='methods'><li data-type='method'><a href="UserAgentRotatorFn.html#addUserAgent">addUserAgent</a></li><li data-type='method'><a href="UserAgentRotatorFn.html#filterUserAgents">filterUserAgents</a></li><li data-type='method'><a href="UserAgentRotatorFn.html#getCurrent">getCurrent</a></li><li data-type='method'><a href="UserAgentRotatorFn.html#getInfo">getInfo</a></li><li data-type='method'><a href="UserAgentRotatorFn.html#getNext">getNext</a></li><li data-type='method'><a href="UserAgentRotatorFn.html#getRandom">getRandom</a></li><li data-type='method'><a href="UserAgentRotatorFn.html#reset">reset</a></li><li data-type='method'><a href="UserAgentRotatorFn.html#setType">setType</a></li></ul></li><li><a href="UtilsArrays.html">UtilsArrays</a><ul class='methods'><li data-type='method'><a href="UtilsArrays.html#.accumulate">accumulate</a></li><li data-type='method'><a href="UtilsArrays.html#.average">average</a></li><li data-type='method'><a href="UtilsArrays.html#.chunk">chunk</a></li><li data-type='method'><a href="UtilsArrays.html#.countOccurrences">countOccurrences</a></li><li data-type='method'><a href="UtilsArrays.html#.firstIndex">firstIndex</a></li><li data-type='method'><a href="UtilsArrays.html#.firstObjMatch">firstObjMatch</a></li><li data-type='method'><a href="UtilsArrays.html#.generateObjectArray">generateObjectArray</a></li><li data-type='method'><a href="UtilsArrays.html#.getIntersection">getIntersection</a></li><li data-type='method'><a href="UtilsArrays.html#.indexOfMax">indexOfMax</a></li><li data-type='method'><a href="UtilsArrays.html#.indexOfMin">indexOfMin</a></li><li data-type='method'><a href="UtilsArrays.html#.indices">indices</a></li><li data-type='method'><a href="UtilsArrays.html#.insertElements">insertElements</a></li><li data-type='method'><a href="UtilsArrays.html#.isEqualArray">isEqualArray</a></li><li data-type='method'><a href="UtilsArrays.html#.lastIndex">lastIndex</a></li><li data-type='method'><a href="UtilsArrays.html#.partition">partition</a></li><li data-type='method'><a href="UtilsArrays.html#.randomItem">randomItem</a></li><li data-type='method'><a href="UtilsArrays.html#.range">range</a></li><li data-type='method'><a href="UtilsArrays.html#.removeDuplicate">removeDuplicate</a></li><li data-type='method'><a href="UtilsArrays.html#.removeDuplicatesArrObj">removeDuplicatesArrObj</a></li><li data-type='method'><a href="UtilsArrays.html#.shuffle">shuffle</a></li><li data-type='method'><a href="UtilsArrays.html#.swapItems">swapItems</a></li><li data-type='method'><a href="UtilsArrays.html#.unionArrays">unionArrays</a></li></ul></li><li><a href="UtilsNumbers.html">UtilsNumbers</a><ul class='methods'><li data-type='method'><a href="UtilsNumbers.html#.arithmeticProgression">arithmeticProgression</a></li><li data-type='method'><a href="UtilsNumbers.html#.factorial">factorial</a></li><li data-type='method'><a href="UtilsNumbers.html#.fibonacci">fibonacci</a></li><li data-type='method'><a href="UtilsNumbers.html#.gcdMultiple">gcdMultiple</a></li><li data-type='method'><a href="UtilsNumbers.html#.geometricProgression">geometricProgression</a></li><li data-type='method'><a href="UtilsNumbers.html#.lcmMultiple">lcmMultiple</a></li><li data-type='method'><a href="UtilsNumbers.html#.logBase">logBase</a></li><li data-type='method'><a href="UtilsNumbers.html#.randomIntArrayInRange">randomIntArrayInRange</a></li><li data-type='method'><a href="UtilsNumbers.html#.randomNumberGenerator">randomNumberGenerator</a></li><li data-type='method'><a href="UtilsNumbers.html#.roundNumber">roundNumber</a></li><li data-type='method'><a href="UtilsNumbers.html#.toFixed">toFixed</a></li></ul></li><li><a href="UtilsObject.html">UtilsObject</a><ul class='methods'><li data-type='method'><a href="UtilsObject.html#.combinedObjectWithArrays">combinedObjectWithArrays</a></li><li data-type='method'><a href="UtilsObject.html#.commonKeys">commonKeys</a></li><li data-type='method'><a href="UtilsObject.html#.countBy">countBy</a></li><li data-type='method'><a href="UtilsObject.html#.getCommonKeys">getCommonKeys</a></li><li data-type='method'><a href="UtilsObject.html#.getObjFromKey">getObjFromKey</a></li><li data-type='method'><a href="UtilsObject.html#.groupBy">groupBy</a></li><li data-type='method'><a href="UtilsObject.html#.isEqualObj">isEqualObj</a></li><li data-type='method'><a href="UtilsObject.html#.maxBy">maxBy</a></li><li data-type='method'><a href="UtilsObject.html#.minBy">minBy</a></li><li data-type='method'><a href="UtilsObject.html#.pluck">pluck</a></li><li data-type='method'><a href="UtilsObject.html#.removeArrayFromValues">removeArrayFromValues</a></li><li data-type='method'><a href="UtilsObject.html#.removeDuplicatesByProperty">removeDuplicatesByProperty</a></li><li data-type='method'><a href="UtilsObject.html#.removeDuplicatesFromValues">removeDuplicatesFromValues</a></li><li data-type='method'><a href="UtilsObject.html#.removeNullUndefined">removeNullUndefined</a></li><li data-type='method'><a href="UtilsObject.html#.removeObjectSafely">removeObjectSafely</a></li><li data-type='method'><a href="UtilsObject.html#.renameKeys">renameKeys</a></li><li data-type='method'><a href="UtilsObject.html#.sortBy">sortBy</a></li><li data-type='method'><a href="UtilsObject.html#.sortObj">sortObj</a></li><li data-type='method'><a href="UtilsObject.html#.splitObjInKeys">splitObjInKeys</a></li><li data-type='method'><a href="UtilsObject.html#.toObject">toObject</a></li></ul></li><li><a href="UtilsString.html">UtilsString</a><ul class='methods'><li data-type='method'><a href="UtilsString.html#.bytesString">bytesString</a></li><li data-type='method'><a href="UtilsString.html#.camelToKebab">camelToKebab</a></li><li data-type='method'><a href="UtilsString.html#.capitalize">capitalize</a></li><li data-type='method'><a href="UtilsString.html#.characterCount">characterCount</a></li><li data-type='method'><a href="UtilsString.html#.cleanText">cleanText</a></li><li data-type='method'><a href="UtilsString.html#.concatWS">concatWS</a></li><li data-type='method'><a href="UtilsString.html#.countWords">countWords</a></li><li data-type='method'><a href="UtilsString.html#.decodeHtmlEntities">decodeHtmlEntities</a></li><li data-type='method'><a href="UtilsString.html#.decomposeUrl">decomposeUrl</a></li><li data-type='method'><a href="UtilsString.html#.ext">ext</a></li><li data-type='method'><a href="UtilsString.html#.extractNumber">extractNumber</a></li><li data-type='method'><a href="UtilsString.html#.generateString">generateString</a></li><li data-type='method'><a href="UtilsString.html#.isPalindrome">isPalindrome</a></li><li data-type='method'><a href="UtilsString.html#.kebabToCamel">kebabToCamel</a></li><li data-type='method'><a href="UtilsString.html#.mask">mask</a></li><li data-type='method'><a href="UtilsString.html#.prependNumbers">prependNumbers</a></li><li data-type='method'><a href="UtilsString.html#.removeAcents">removeAcents</a></li><li data-type='method'><a href="UtilsString.html#.removeEmptyLines">removeEmptyLines</a></li><li data-type='method'><a href="UtilsString.html#.replaceSpaces">replaceSpaces</a></li><li data-type='method'><a href="UtilsString.html#.slugify">slugify</a></li><li data-type='method'><a href="UtilsString.html#.sortLines">sortLines</a></li><li data-type='method'><a href="UtilsString.html#.toCamelCase">toCamelCase</a></li><li data-type='method'><a href="UtilsString.html#.toPascalCase">toPascalCase</a></li><li data-type='method'><a href="UtilsString.html#.trim">trim</a></li><li data-type='method'><a href="UtilsString.html#.truncate">truncate</a></li><li data-type='method'><a href="UtilsString.html#.upperCaseWords">upperCaseWords</a></li></ul></li><li><a href="Validator.html">Validator</a><ul class='methods'><li data-type='method'><a href="Validator.html#.areArraySame">areArraySame</a></li><li data-type='method'><a href="Validator.html#.indexInRange">indexInRange</a></li><li data-type='method'><a href="Validator.html#.isArray">isArray</a></li><li data-type='method'><a href="Validator.html#.isBigInt">isBigInt</a></li><li data-type='method'><a href="Validator.html#.isBoolean">isBoolean</a></li><li data-type='method'><a href="Validator.html#.isEmpty">isEmpty</a></li><li data-type='method'><a href="Validator.html#.isEncoded">isEncoded</a></li><li data-type='method'><a href="Validator.html#.isFloat">isFloat</a></li><li data-type='method'><a href="Validator.html#.isFunction">isFunction</a></li><li data-type='method'><a href="Validator.html#.isInteger">isInteger</a></li><li data-type='method'><a href="Validator.html#.isNil">isNil</a></li><li data-type='method'><a href="Validator.html#.isNull">isNull</a></li><li data-type='method'><a href="Validator.html#.isNumber">isNumber</a></li><li data-type='method'><a href="Validator.html#.isObject">isObject</a></li><li data-type='method'><a href="Validator.html#.isOneDimensional">isOneDimensional</a></li><li data-type='method'><a href="Validator.html#.isString">isString</a></li><li data-type='method'><a href="Validator.html#.isSymbol">isSymbol</a></li><li data-type='method'><a href="Validator.html#.isType">isType</a></li><li data-type='method'><a href="Validator.html#.isUndefined">isUndefined</a></li><li data-type='method'><a href="Validator.html#.isValidType">isValidType</a></li><li data-type='method'><a href="Validator.html#.validateObject">validateObject</a></li></ul></li><li><a href="module-Various-ProductStateProcessor.html">ProductStateProcessor</a><ul class='methods'><li data-type='method'><a href="module-Various-ProductStateProcessor.html#extractJsonValues">extractJsonValues</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#extractVariantIds">extractVariantIds</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#findPriceTableKey">findPriceTableKey</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#findProductsBySpecification">findProductsBySpecification</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#getPriceInfo">getPriceInfo</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#getProducts">getProducts</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#isProductKey">isProductKey</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processAssemblyOptions">processAssemblyOptions</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processClusterHighlights">processClusterHighlights</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processCommercialOffer">processCommercialOffer</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processItemMetadata">processItemMetadata</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processItemMetadataWithAssemblyOptions">processItemMetadataWithAssemblyOptions</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processProduct">processProduct</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processProductClusters">processProductClusters</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processProperties">processProperties</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processSellers">processSellers</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processSkuSpecifications">processSkuSpecifications</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processSpecificationGroups">processSpecificationGroups</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processVariant">processVariant</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#processVariants">processVariants</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#resolveReferences">resolveReferences</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#unwrapIfOnlyOne">unwrapIfOnlyOne</a></li><li data-type='method'><a href="module-Various-ProductStateProcessor.html#validateInputs">validateInputs</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-Various.html">Various</a><ul class='methods'><li data-type='method'><a href="module-Various.html#.applyMixins">applyMixins</a></li><li data-type='method'><a href="module-Various.html#.bubbleSort">bubbleSort</a></li><li data-type='method'><a href="module-Various.html#.bucketSort">bucketSort</a></li><li data-type='method'><a href="module-Various.html#.convertirMilisegundos">convertirMilisegundos</a></li><li data-type='method'><a href="module-Various.html#.decimalToHex">decimalToHex</a></li><li data-type='method'><a href="module-Various.html#.decodeJWT">decodeJWT</a></li><li data-type='method'><a href="module-Various.html#.detectAlphabet">detectAlphabet</a></li><li data-type='method'><a href="module-Various.html#.generateShades">generateShades</a></li><li data-type='method'><a href="module-Various.html#.generateUniqueId">generateUniqueId</a></li><li data-type='method'><a href="module-Various.html#.getComplementaryColor">getComplementaryColor</a></li><li data-type='method'><a href="module-Various.html#.getMainAlphabet">getMainAlphabet</a></li><li data-type='method'><a href="module-Various.html#.getMaxByProperty">getMaxByProperty</a></li><li data-type='method'><a href="module-Various.html#.getSuplementaryColor">getSuplementaryColor</a></li><li data-type='method'><a href="module-Various.html#.getTypeOf">getTypeOf</a></li><li data-type='method'><a href="module-Various.html#.getVariablesInText">getVariablesInText</a></li><li data-type='method'><a href="module-Various.html#.heapsort">heapsort</a></li><li data-type='method'><a href="module-Various.html#.hexToDecimal">hexToDecimal</a></li><li data-type='method'><a href="module-Various.html#.hexToHSL">hexToHSL</a></li><li data-type='method'><a href="module-Various.html#.hexToRgb">hexToRgb</a></li><li data-type='method'><a href="module-Various.html#.hslToHex">hslToHex</a></li><li data-type='method'><a href="module-Various.html#.hslToRgb">hslToRgb</a></li><li data-type='method'><a href="module-Various.html#.insertionSort">insertionSort</a></li><li data-type='method'><a href="module-Various.html#.measureAsyncFn">measureAsyncFn</a></li><li data-type='method'><a href="module-Various.html#.measureSyncFn">measureSyncFn</a></li><li data-type='method'><a href="module-Various.html#.mergeSort">mergeSort</a></li><li data-type='method'><a href="module-Various.html#.myDecodeURI">myDecodeURI</a></li><li data-type='method'><a href="module-Various.html#.myEncodeURI">myEncodeURI</a></li><li data-type='method'><a href="module-Various.html#.normalizeUrl">normalizeUrl</a></li><li data-type='method'><a href="module-Various.html#.parseJSONToString">parseJSONToString</a></li><li data-type='method'><a href="module-Various.html#.parseStringToJSON">parseStringToJSON</a></li><li data-type='method'><a href="module-Various.html#.pipe">pipe</a></li><li data-type='method'><a href="module-Various.html#.quickSort">quickSort</a></li><li data-type='method'><a href="module-Various.html#.randomBoolean">randomBoolean</a></li><li data-type='method'><a href="module-Various.html#.randomColorHex">randomColorHex</a></li><li data-type='method'><a href="module-Various.html#.rgbToHex">rgbToHex</a></li><li data-type='method'><a href="module-Various.html#.rgbToHsl">rgbToHsl</a></li><li data-type='method'><a href="module-Various.html#.secondsToTimeString">secondsToTimeString</a></li><li data-type='method'><a href="module-Various.html#.selectionSort">selectionSort</a></li><li data-type='method'><a href="module-Various.html#.timeStringToSeconds">timeStringToSeconds</a></li><li data-type='method'><a href="module-Various.html#.timestampToutc">timestampToutc</a></li><li data-type='method'><a href="module-Various.html#.wait">wait</a></li><li data-type='method'><a href="module-Various.html#~extractCleanObjects">extractCleanObjects</a></li><li data-type='method'><a href="module-Various.html#~sortByArray">sortByArray</a></li><li data-type='method'><a href="module-Various.html#~sortElementsByReferenceArray">sortElementsByReferenceArray</a></li><li data-type='method'><a href="module-Various.html#~timeStringTo">timeStringTo</a></li><li data-type='method'><a href="module-Various.html#~timeToString">timeToString</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#analizarBuffer">analizarBuffer</a></li><li><a href="global.html#base64ABuffer">base64ABuffer</a></li><li><a href="global.html#bufferAFormatos">bufferAFormatos</a></li><li><a href="global.html#bufferAImagen">bufferAImagen</a></li><li><a href="global.html#bufferAImagenAsync">bufferAImagenAsync</a></li><li><a href="global.html#compararBuffers">compararBuffers</a></li><li><a href="global.html#crearHashImagen">crearHashImagen</a></li><li><a href="global.html#descargarImagenABuffer">descargarImagenABuffer</a></li><li><a href="global.html#detectarFormato">detectarFormato</a></li><li><a href="global.html#esImagenValida">esImagenValida</a></li><li><a href="global.html#guardarConMetadatos">guardarConMetadatos</a></li><li><a href="global.html#guardarImagenConFormato">guardarImagenConFormato</a></li><li><a href="global.html#mixinArrays">mixinArrays</a></li><li><a href="global.html#streamABuffer">streamABuffer</a></li><li><a href="global.html#validarBufferImagen">validarBufferImagen</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">various-fn.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module Various
 */

/**
 * La función `wait` devuelve una promesa que se resuelve
 * después de esperar la cantidad de tiempo especificada
 * en milisegundos (valor por defecto 1 segundo).
 * Esto puede ser útil en situaciones donde necesitas pausar
 * la ejecución de cierto código durante un período de tiempo
 * específico, como en operaciones asíncronas o en situaciones
 * donde necesitas controlar el flujo de ejecución de manera temporal.
 * @param {number} ms=1000 Cantidad de milisegundos a esperar.
 * @returns {Promise} Retorna una promesa que no resuelve nada.
 * @example
 * console.log('Inicio del programa');
 *
 * wait(2000) // Espera 2 segundos (2000 milisegundos)
 *   .then(() => {
 *     console.log('Han pasado 2 segundos');
 *     return wait(3000); // Espera 3 segundos adicionales
 *   })
 *   .then(() => {
 *     console.log('Han pasado 5 segundos en total');
 *   });
 *
 * console.log('Fin del programa');
 * // Inicio del programa
 * // Fin del programa
 * // Han pasado 2 segundos
 * // Han pasado 5 segundos en total
 * @example
 * console.log('Inicio del programa');
 * await wait(); // Espera 1 segundo (1000 milisegundos)
 * console.log('Continua la ejecución del programa');
 */
export function wait(ms = 1000) {
    return new Promise((resuelve) => setTimeout(resuelve, ms))
}

/**
 * Permite decodificar un token JWT.
 * @param {string} token Token a decodificar.
 * @returns {Object} Retorna un objeto con los datos decodificados.
 * @example
 * decode(`
 *     eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
 *     eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0I
 *     joxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
 * `);
 *
 * // { "sub": "1234567890", "name": "John Doe", "iat": 1516239022 }
 */
export function decodeJWT(token) {
    return decodeURIComponent(atob(token.split('.')[1].replace('-', '+').replace('_', '/'))
        .split('')
        .map((c) => `%${('00' + c.charCodeAt(0).toString(16)).slice(-2)}`)
        .join(''));
}

/**
 * Permite obtener el tipo de una variable en un string.
 * @param obj Variable que se desea conocer el tipo.
 * @returns {string} Retorna un string con el nombre del tipo de variable.
 * @example
 * getTypeOf('hello world'); // String
 * getTypeOf(1000); // Number
 * getTypeOf(Infinity); // Number
 * getTypeOf(true); // Boolean
 * getTypeOf(Symbol()); // Symbol
 * getTypeOf(null); // Null
 * getTypeOf(undefined); // Undefined
 * getTypeOf({}); // Object
 * getTypeOf([]); // Array
 * getTypeOf(/[a-z]/g); // RegExp
 * getTypeOf(new Date(2021)); // Date
 * getTypeOf(new Error()); // Error
 * getTypeOf(function () {}); // Function
 * getTypeOf((a, b) => a + b); // Function
 * getTypeOf(async () => {}); // AsyncFunction
 * getTypeOf(document); // HTMLDocument
 */
export function getTypeOf(obj) {
    return Object.prototype.toString.call(obj).match(/\[object (.*)\]/)[1];
}

/**
 * Genera un ramdom color hex.
 * @returns {string} Retorna el color en hex.
 * @example
 * randomColorHex()
 * //#060c7c
 */
export function randomColorHex() {
    return `#${Math.random().toString(16).slice(2, 8).padEnd(6, '0')}`;
}

/**
 * Codificar una URL
 * @param url URL a codificar.
 * @returns {string} Retorna la URL codificada.
 */
export function myEncodeURI(url) {
    return encodeURIComponent(url)
        .replace(/!/g, '%21')
        .replace(/~/g, '%7E')
        .replace(/\*/g, '%2A')
        .replace(/'/g, '%27')
        .replace(/\(/g, '%28')
        .replace(/\)/g, '%29')
        .replace(/\+/g, '%20');
}

/**
 * Decodificar una URL
 * @param url URL a decodificar.
 * @returns {string} Retorna la URL decodificada.
 */
export function myDecodeURI(url) {
    return decodeURIComponent(url)
        .replace(/%21/g, '!')
        .replace(/%7E/g, '~')
        .replace(/%2A/g, '*')
        .replace(/%27/g, "'")
        .replace(/%28/g, '(')
        .replace(/%29/g, ')')
        .replace(/%20/g, '+');
}

/**
 * Función que implementa una tubería de funciones.
 * @param {...Function} functions - Funciones a ser ejecutadas en orden.
 * @returns {Function} - Función que ejecuta las funciones en secuencia.
 */
export function pipe(...functions) {
    return input =>
        functions.reduce((acc, fn) => fn(acc), input);
}

/**
 * Convierte un color en formato hexadecimal a HSL (Hue, Saturation, Lightness).
 * @param {string} hex - Color en formato hexadecimal.
 * @returns {Array} - Array con los valores HSL.
 */
export function hexToHSL(hex) {
    let r = 0, g = 0, b = 0; // Inicializa los valores de rojo, verde y azul.
    if (hex.length === 4) { // Verifica si el color es de 4 dígitos.
        r = parseInt(hex[1] + hex[1], 16); // Calcula el valor de rojo.
        g = parseInt(hex[2] + hex[2], 16); // Calcula el valor de verde.
        b = parseInt(hex[3] + hex[3], 16); // Calcula el valor de azul.
    } else if (hex.length === 7) { // Verifica si el color es de 7 dígitos.
        r = parseInt(hex[1] + hex[2], 16); // Calcula el valor de rojo.
        g = parseInt(hex[3] + hex[4], 16); // Calcula el valor de verde.
        b = parseInt(hex[5] + hex[6], 16); // Calcula el valor de azul.
    }
    r /= 255; // Normaliza el valor de rojo.
    g /= 255; // Normaliza el valor de verde.
    b /= 255; // Normaliza el valor de azul.
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h = 0, s = 0, l = (max + min) / 2; // Calcula los valores de máximo, mínimo, matiz, saturación y luminosidad.
    if (max !== min) { // Verifica si el color no es una escala de grises.
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g &lt; b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return [h, s, l]; // Devuelve el array con los valores HSL.
}

/**
 * Convierte un color de formato HSL a formato hexadecimal.
 * @param {number} h - Matiz (hue) en grados.
 * @param {number} s - Saturación (saturation) en porcentaje.
 * @param {number} l - Luminosidad (lightness) en porcentaje.
 * @returns {string} - Color en formato hexadecimal.
 */
export function hslToHex(h, s, l) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l; // Si la saturación es 0, el color es acromático.
    } else {
        const hue2rgb = (p, q, t) => {
            if (t &lt; 0) t += 1;
            if (t > 1) t -= 1;
            if (t &lt; 1 / 6) return p + (q - p) * 6 * t;
            if (t &lt; 1 / 2) return q;
            if (t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        let q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    r = Math.round(r * 255);
    g = Math.round(g * 255);
    b = Math.round(b * 255);

    return "#" + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);
}

/**
 * Función para obtener el color complementario de un color en formato hexadecimal.
 * @param {string} hex - Color en formato hexadecimal.
 * @returns {string} - Color complementario en formato hexadecimal.
 */
export function getComplementaryColor(hex) {
    let [h, s, l] = hexToHSL(hex);
    h = (h + 0.5) % 1.0; // Sumar 180 grados al matiz para obtener el color complementario
    return hslToHex(h, s, l);
}

/**
 * Convierte un color hexadecimal a RGB.
 * @param {string} hex - Color hexadecimal a convertir.
 * @returns {Array} - Arreglo con los valores RGB.
 */
export function hexToRgb(hex) {
    // Eliminar el signo # si está presente
    hex = hex.replace(/^#/, '');

    // Convertir el color hexadecimal a RGB
    let bigint = parseInt(hex, 16);
    let r = (bigint >> 16) &amp; 255; // Extraer el componente rojo
    let g = (bigint >> 8) &amp; 255; // Extraer el componente verde
    let b = bigint &amp; 255; // Extraer el componente azul

    return [r, g, b]; // Devolver un arreglo con los valores RGB
}

/**
 * Convierte los valores RGB a hexadecimal.
 * @param {number} r - Valor de rojo (0-255).
 * @param {number} g - Valor de verde (0-255).
 * @param {number} b - Valor de azul (0-255).
 * @returns {string} Representación hexadecimal del color RGB.
 */
export function rgbToHex(r, g, b) {
    // Se realiza la conversión de los valores RGB a su representación hexadecimal
    return "#" + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1).toUpperCase();
}

/**
 * Convierte un color RGB a HSL (Hue, Saturation, Lightness).
 * @param {number} r - Valor de rojo (0-255).
 * @param {number} g - Valor de verde (0-255).
 * @param {number} b - Valor de azul (0-255).
 * @returns {Array} - Array con los valores de HSL.
 */
export function rgbToHsl(r, g, b) {
    // Normalizar los valores RGB al rango 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    let max = Math.max(r, g, b);
    let min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // Si el máximo y el mínimo son iguales, el color es gris
    } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g &lt; b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }

    return [h * 360, s, l]; // Devuelve los valores de HSL
}

/**
 * Convierte un color de formato HSL a RGB.
 * @param {number} h - Matiz (hue) en grados.
 * @param {number} s - Saturación (saturation) como un valor entre 0 y 1.
 * @param {number} l - Luminosidad (lightness) como un valor entre 0 y 1.
 * @returns {Array} - Un arreglo con los valores RGB resultantes.
 */
export function hslToRgb(h, s, l) {
    let r, g, b;

    if (s === 0) {
        // Si la saturación es 0, el color es una escala de grises
        r = g = b = l;
    } else {
        function hue2rgb(p, q, t) {
            if (t &lt; 0) t += 1;
            if (t > 1) t -= 1;
            if (t &lt; 1 / 6) return p + (q - p) * 6 * t;
            if (t &lt; 1 / 3) return q;
            if (t &lt; 1 / 2) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }

        let q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        h /= 360;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r * 255, g * 255, b * 255];
}

/**
 * Función para obtener el color suplementario de un color hexadecimal.
 * @param {string} hex - Color hexadecimal.
 * @param {number} angle=25 - Ángulo para calcular el color suplementario.
 * @returns {string} Color hexadecimal suplementario.
 */
export function getSuplementaryColor(hex, angle = 25) {
    // Convertir el color hexadecimal a RGB
    let [r, g, b] = hexToRgb(hex);

    // Convertir RGB a HSL
    let [h, s, l] = rgbToHsl(r, g, b);

    // Calcular el nuevo tono (H) sumando el ángulo y asegurándose de que esté en el rango [0, 360)
    h = (h + angle) % 360;
    if (h &lt; 0) h += 360;

    // Convertir el nuevo HSL a RGB
    let [adjR, adjG, adjB] = hslToRgb(h, s, l);

    // Convertir el nuevo RGB a hexadecimal y devolverlo
    return rgbToHex(Math.round(adjR), Math.round(adjG), Math.round(adjB));
}

/**
 * Función para generar una serie de tonos a partir de un color hexadecimal dado.
 * @param {string} hex - Color hexadecimal base.
 * @param {number} numOfShades - Número de tonos a generar (por defecto 10).
 * @param {number} percentageDifference - Diferencia porcentual entre tonos adyacentes (por defecto 10).
 * @returns {Array} - Arreglo con los tonos generados.
 */
export function generateShades(hex, numOfShades = 10, percentageDifference = 10) {
    // Convertir el color hexadecimal a RGB
    let [r, g, b] = hexToRgb(hex);
    let shades = [];

    // Generar los tonos
    for (let i = 0; i &lt; numOfShades; i++) {
        // Calcular el factor de ajuste para el tono actual
        let factor = 1 + (percentageDifference / 100) * (i - Math.floor(numOfShades / 2));
        // Calcular los componentes RGB del tono
        let shadeR = Math.min(255, Math.max(0, Math.round(r * factor)));
        let shadeG = Math.min(255, Math.max(0, Math.round(g * factor)));
        let shadeB = Math.min(255, Math.max(0, Math.round(b * factor)));
        // Convertir los componentes RGB a color hexadecimal y agregarlo al arreglo de tonos
        shades.push(rgbToHex(shadeR, shadeG, shadeB));
    }

    return shades;
}

/**
 * Función que convierte una cadena en formato clave-valor a un objeto JSON.
 * @param {string} str - La cadena en formato clave-valor a convertir.
 * @param {string} separatorPair - El separador entre pares clave-valor (por defecto ';').
 * @param {string} separatorValue - El separador entre clave y valor (por defecto '=').
 * @returns {object} - Objeto JSON con las claves y valores extraídos de la cadena.
 */
export function parseStringToJSON(str, separatorPair = ';', separatorValue = '=') {
    const result = {};
    const pairs = str.split(separatorPair).filter(Boolean).map(pair => pair.trim()); // Divide la cadena en pares clave-valor y elimina espacios en blanco.
    pairs.forEach(pair => {
        // Divide el par en clave y valor.
        const sep = pair.indexOf(separatorValue);
        const key = pair.substring(0, sep);
        const value = pair.substring(sep + 1);
        let parsedValue;
        if (value === undefined) { // Comprueba si el valor es indefinido.
            parsedValue = '';
        } else if (!isNaN(Number(value)) &amp;&amp; value.trim() !== '') { // Verifica si el valor es numérico.
            parsedValue = Number(value); // Convierte el valor a número.
        } else if (['true', 'false'].includes(value.toLowerCase())) { // Comprueba si el valor es booleano.
            parsedValue = value.toLowerCase() === 'true'; // Convierte el valor booleano a booleano.
        } else {
            parsedValue = value; // Asigna el valor como cadena.
        }
        result[key] = parsedValue; // Asigna el valor parseado a la clave correspondiente en el objeto JSON.
    });
    return result; // Devuelve el objeto JSON resultante.
}

/**
 * Función que convierte un objeto JSON en una cadena en formato clave-valor.
 * @param {object} obj - El objeto JSON a convertir.
 * @param {string} separatorPair - El separador entre pares clave-valor (por defecto ';').
 * @param {string} separatorValue - El separador entre clave y valor (por defecto '=').
 * @returns {string} - Cadena en formato clave-valor.
 */
export function parseJSONToString(obj, separatorPair = '; ', separatorValue = '=') {
    return Object.entries(obj)
        .map(([key, value]) => {
            let stringValue;

            if (typeof value === 'boolean') {
                stringValue = value ? 'true' : 'false'; // Convierte booleano a cadena.
            } else if (value === undefined || value === null) {
                stringValue = ''; // Convierte indefinido o nulo a cadena vacía.
            } else {
                stringValue = String(value); // Convierte otros tipos a cadena.
            }

            return `${key}${separatorValue}${stringValue}`; // Forma el par clave-valor.
        })
        .join(separatorPair); // Une todos los pares con el separador especificado.
}


/**
 * Función para ordenar un arreglo utilizando el algoritmo de Quick Sort.
 * @param {Array} arr - El arreglo que se desea ordenar.
 * @returns {Array} - El arreglo ordenado.
 * @example
 * quickSort([1, 6, 1, 5, 3, 2, 1, 4]);
 * // [1, 1, 1, 2, 3, 4, 5, 6]
 */
export function quickSort(arr) {
    // Se crea una copia del arreglo para no modificar el original
    const a = [...arr];

    // Caso base: si el arreglo tiene menos de 2 elementos, se devuelve el arreglo
    if (a.length &lt; 2) return a;

    // Se calcula el índice del pivote
    const pivotIndex = Math.floor(arr.length / 2);
    const pivot = a[pivotIndex]; // Se obtiene el valor del pivote

    // Se separan los elementos menores y mayores que el pivote
    const [lo, hi] = a.reduce(
        (acc, val, i) => {
            if (val &lt; pivot || (val === pivot &amp;&amp; i != pivotIndex)) {
                acc[0].push(val); // Se añade al arreglo de menores
            } else if (val > pivot) {
                acc[1].push(val); // Se añade al arreglo de mayores
            }
            return acc;
        },
        [[], []]
    );

    // Se aplica recursivamente quickSort a los subarreglos menores y mayores, y se concatena con el pivote
    return [...quickSort(lo), pivot, ...quickSort(hi)];
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo Merge Sort.
 * @param {Array} arr - El arreglo a ordenar.
 * @returns {Array} - El arreglo ordenado.
 * @example
 * mergeSort([5, 1, 4, 2, 3]);
 * // [1, 2, 3, 4, 5]
 */
export function mergeSort(arr) {
    // Verificar si el arreglo tiene menos de 2 elementos
    if (arr.length &lt; 2) return arr;

    // Calcular el punto medio del arreglo
    const mid = Math.floor(arr.length / 2);

    // Dividir el arreglo en dos partes y llamar recursivamente a mergeSort
    const l = mergeSort(arr.slice(0, mid));
    const r = mergeSort(arr.slice(mid, arr.length));

    // Combinar y ordenar las dos partes del arreglo
    return Array.from({ length: l.length + r.length }, () => {
        // Verificar si alguna de las partes ya no tiene elementos
        if (!l.length) return r.shift();
        else if (!r.length) return l.shift();
        // Comparar y combinar los elementos de las dos partes
        else return l[0] > r[0] ? r.shift() : l.shift();
    });
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo de heapsort.
 * @param {Array} arr - Arreglo a ordenar.
 * @returns {Array} - Arreglo ordenado.
 * @example
 * heapsort([6, 3, 4, 1]);
 * // [1, 3, 4, 6]
 */
export function heapsort(arr) {
    // Se crea una copia del arreglo para no modificar el original
    const a = [...arr];
    let l = a.length;

    // Función para convertir el arreglo en un heap
    const heapify = (a, i) => {
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        let max = i;
        if (left &lt; l &amp;&amp; a[left] > a[max]) max = left;
        if (right &lt; l &amp;&amp; a[right] > a[max]) max = right;
        if (max !== i) {
            [a[max], a[i]] = [a[i], a[max]];
            heapify(a, max);
        }
    };

    // Se convierte el arreglo en un heap
    for (let i = Math.floor(l / 2); i >= 0; i -= 1) heapify(a, i);

    // Se ordena el heap
    for (let i = a.length - 1; i > 0; i--) {
        [a[0], a[i]] = [a[i], a[0]];
        l--;
        heapify(a, 0);
    }
    return a;
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo de Bubble Sort.
 * @param {Array} arr - El arreglo a ordenar.
 * @returns {Array} - El arreglo ordenado.
 * @example
 * bubbleSort([2, 1, 4, 3]);
 * // [1, 2, 3, 4]
 */
export function bubbleSort(arr) {
    let swapped = false; // Variable para controlar si se realizó un intercambio en la iteración actual.
    const a = [...arr]; // Se crea una copia del arreglo para no modificar el original.
    for (let i = 1; i &lt; a.length; i++) { // Bucle externo para recorrer el arreglo.
        swapped = false; // Se reinicia la variable de intercambio en cada iteración.
        for (let j = 0; j &lt; a.length - i; j++) { // Bucle interno para comparar elementos y realizar intercambios.
            if (a[j + 1] &lt; a[j]) { // Si el elemento siguiente es menor que el actual, se intercambian.
                [a[j], a[j + 1]] = [a[j + 1], a[j]]; // Intercambio de elementos.
                swapped = true; // Se marca que se realizó un intercambio.
            }
        }
        if (!swapped) return a; // Si no se realizó ningún intercambio en la iteración, el arreglo está ordenado.
    }
    return a; // Se devuelve el arreglo ordenado.
}

/**
 * Función que implementa el algoritmo de ordenamiento por inserción.
 * @param {Array} arr - El arreglo que se va a ordenar.
 * @returns {Array} - El arreglo ordenado.
 */
export function insertionSort(arr) {
    return arr.reduce((acc, x) => {
        if (!acc.length) return [x]; // Si el arreglo está vacío, se agrega el primer elemento.
        acc.some((y, j) => {
            if (x &lt;= y) {
                acc.splice(j, 0, x); // Se inserta el elemento en la posición correcta.
                return true;
            }
            if (x > y &amp;&amp; j === acc.length - 1) {
                acc.splice(j + 1, 0, x); // Se inserta el elemento al final del arreglo.
                return true;
            }
            return false;
        });
        return acc;
    }, []);
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo de Selection Sort.
 * @param {Array} arr - El arreglo que se desea ordenar.
 * @returns {Array} - El arreglo ordenado.
 */
export function selectionSort(arr) {
    // Se crea una copia del arreglo para no modificar el original
    const a = [...arr];

    // Iteración sobre el arreglo
    for (let i = 0; i &lt; a.length; i++) {
        // Encontrar el índice del elemento mínimo en el subarreglo restante
        const min = a
            .slice(i + 1)
            .reduce((acc, val, j) => (val &lt; a[acc] ? j + i + 1 : acc), i);

        // Intercambiar elementos si es necesario
        if (min !== i) [a[i], a[min]] = [a[min], a[i]];
    }

    // Devolver el arreglo ordenado
    return a;
}

/**
 * Función para ordenar un arreglo utilizando el algoritmo Bucket Sort.
 * @param {Array} arr - Arreglo a ordenar.
 * @param {number} size - Tamaño de los buckets (por defecto es 5).
 * @returns {Array} - Arreglo ordenado.
 */
export function bucketSort(arr, size = 5) {
    // Encontrar el valor mínimo y máximo en el arreglo
    const min = Math.min(...arr);
    const max = Math.max(...arr);

    // Crear los buckets basados en el tamaño y rango de valores
    const buckets = Array.from(
        { length: Math.floor((max - min) / size) + 1 },
        () => []
    );

    // Colocar cada elemento del arreglo en el bucket correspondiente
    arr.forEach(val => {
        buckets[Math.floor((val - min) / size)].push(val);
    });

    // Ordenar cada bucket y combinarlos en un solo arreglo ordenado
    return buckets.reduce((acc, b) => [...acc, ...b.sort((a, b) => a - b)], []);
}

/**
 * Convierte un número decimal a su equivalente en hexadecimal.
 * @param {number} dec - Número decimal a convertir.
 * @returns {string} - Número hexadecimal resultante.
 * @example
 * console.log(decimalToHex(0)); // '0'
 * console.log(decimalToHex(255)); // 'ff'
 */
export function decimalToHex(dec) {
    // Utiliza el método toString con base 16 para convertir el número decimal a hexadecimal.
    return dec.toString(16);
}

/**
 * Convierte un número hexadecimal en decimal.
 * @param {string} hex - El número hexadecimal a convertir.
 * @returns {number} El número decimal convertido.
 * @example
 * console.log(hexToDecimal('0')); // 0
 * console.log(hexToDecimal('ff')); // 255
 */
export function hexToDecimal(hex) {
    // Utiliza la función parseInt() con base 16 para convertir el número hexadecimal en decimal.
    return parseInt(hex, 16);
}

/**
 * Función que devuelve un valor booleano aleatorio.
 * @returns {boolean} - Valor booleano aleatorio.
 */
export function randomBoolean() {
    return Math.random() >= 0.5; // Devuelve true si el número aleatorio es mayor o igual a 0.5, de lo contrario, false.
}

/**
 * Genera un ID único basado en un prefijo dado.
 * @param {string} prefix - El prefijo que se añadirá al ID único.
 * @returns {string} - Un ID único en formato 'prefijo-XXXXXXX'.
 */
export function generateUniqueId(prefix) {
    // Genera un número aleatorio y lo convierte a base 36 (alfanumérico)
    // Luego, se extraen los caracteres del índice 2 al 9 para formar la parte única del ID
    return `${prefix}-${Math.random().toString(36).substring(2, 9)}`;
}

/**
 * Convierte un timestamp en segundos a una cadena de fecha en formato UTC.
 * @param {number} timestampSeconds - El timestamp en segundos que se desea convertir.
 * @returns {string|number} - La fecha en formato UTC o el valor original si no es un número válido.
 */
export function timestampToutc(timestampSeconds) {
    // Verifica si el valor proporcionado es un número válido
    if (!/[\d\.]+/.test(String(timestampSeconds))) {
        // Si no es un número válido, retorna el valor original
        return timestampSeconds;
    }
    // Convierte el timestamp de segundos a milisegundos
    const timestampMilliseconds = timestampSeconds * 1000;
    // Crea un objeto Date a partir del timestamp en milisegundos
    const date = new Date(timestampMilliseconds);
    // Retorna la representación de la fecha en formato UTC
    return date.toUTCString();
}

/**
 * Normaliza una URL dada, asegurando que use el protocolo HTTPS.
 * @param {string} url - La URL que se desea normalizar.
 * @param {string} origin - El origen que se usará si la URL es relativa.
 * @returns {string} - La URL normalizada.
 */
export function normalizeUrl(url, origin) {
    // Verifica si la URL comienza con "//", lo que indica un protocolo implícito.
    if (url.startsWith("//")) {
        // Agrega "https:" al inicio de la URL y la codifica.
        return encodeURI(`https:${url}`);
    }
    // Verifica si la URL comienza con "http://".
    if (url.startsWith("http://")) {
        // Reemplaza "http://" por "https://" y codifica la URL.
        return encodeURI(url.replace("http://", "https://"));
    }
    // Verifica si la URL ya comienza con "https://".
    if (url.startsWith("https://")) {
        // Si ya es HTTPS, simplemente la codifica.
        return encodeURI(url);
    }
    // Verifica si la URL es un ancla o la raíz.
    if (url === "#" || url === "/") {
        // Devuelve el origen si la URL es un ancla o la raíz.
        return origin;
    }
    // Si la URL comienza con "/", se considera relativa.
    return url.startsWith("/")
        // Codifica la URL concatenando el origen y la URL relativa.
        ? encodeURI(`${origin}${url}`)
        // Codifica la URL concatenando el origen y la URL, añadiendo una barra.
        : encodeURI(`${origin}/${url}`);
}

/**
 * Función que mide el tiempo de ejecución de una función sincrónica.
 * @param {Function} callBack - La función a medir.
 * @param {...*} args - Los argumentos a pasar a la función.
 * @returns {*} El resultado de la función callBack.
 */
export function measureSyncFn(callBack, ...args) {
    // Verifica si el argumento callBack es una función
    if (typeof callBack !== 'function') {
        throw new TypeError('El argumento callBack debe ser una función.');
    }
    // Marca el inicio del proceso
    performance.mark('inicioProceso');
    // Ejecuta la función callBack con los argumentos proporcionados
    const result = callBack(...args);
    // Marca el fin del proceso
    performance.mark('finProceso');
    // Mide la duración del proceso entre las marcas de inicio y fin
    performance.measure('duraciónProceso', 'inicioProceso', 'finProceso');
    // Obtiene las entradas de medición de rendimiento
    const medidas = performance.getEntriesByType('measure');
    // Verifica si no se registraron medidas de rendimiento
    if (medidas.length === 0) {
        console.log('%cNo se registraron medidas de rendimiento.', 'color: red;');
        return null;
    }
    // Convierte la duración de milisegundos a un formato legible
    const tiempo = convertirMilisegundos(medidas[0].duration);
    // Muestra el tiempo de ejecución en la consola
    console.log('%cEl proceso ha durado: %s', 'color: yellow; background: black;',
        `${String(tiempo.horas).padStart(2, '0')}h ${String(tiempo.minutos).padStart(2, '0')}m ${String(tiempo.segundos).padStart(2, '0')}s || ${medidas[0].duration}ms`);
    // Retorna el resultado de la función callBack
    return result;
}

/**
 * Función que mide el tiempo de ejecución de una función asíncrona.
 * @param {Function} callBack - La función a medir.
 * @param {...*} args - Los argumentos a pasar a la función.
 * @returns {Promise&lt;*>} El resultado de la función callBack.
 */
export async function measureAsyncFn(callBack, ...args) {
    // Verifica si el argumento callBack es una función
    if (typeof callBack !== 'function') {
        throw new TypeError('El argumento callBack debe ser una función.');
    }
    // Marca el inicio del proceso
    performance.mark('inicioProceso');
    // Ejecuta la función callBack de manera asíncrona con los argumentos proporcionados
    const result = await callBack(...args);
    // Marca el fin del proceso
    performance.mark('finProceso');
    // Mide la duración del proceso entre las marcas de inicio y fin
    performance.measure('duraciónProceso', 'inicioProceso', 'finProceso');
    // Obtiene las entradas de medición de rendimiento
    const medidas = performance.getEntriesByType('measure');
    // Verifica si no se registraron medidas de rendimiento
    if (medidas.length === 0) {
        console.log('%cNo se registraron medidas de rendimiento.', 'color: red;');
        return null;
    }
    // Convierte la duración de milisegundos a un formato legible
    const tiempo = convertirMilisegundos(medidas[0].duration);
    // Muestra el tiempo de ejecución en la consola
    console.log('%cEl proceso ha durado: %s', 'color: yellow; background: black;',
        `${String(tiempo.horas).padStart(2, '0')}h ${String(tiempo.minutos).padStart(2, '0')}m ${String(tiempo.segundos).padStart(2, '0')}s || ${medidas[0].duration}ms`);
    // Retorna el resultado de la función callBack
    return result;
}

/**
 * Convierte milisegundos a un objeto que contiene horas, minutos, segundos y milisegundos.
 * @param {number} milisegundos - La cantidad de milisegundos a convertir.
 * @returns {Object} Un objeto con horas, minutos, segundos y milisegundos.
 */
export function convertirMilisegundos(milisegundos) {
    // Calcula el total de segundos a partir de los milisegundos
    const segundosTotales = Math.floor(milisegundos / 1000);
    // Calcula las horas a partir de los segundos totales
    const horas = Math.floor(segundosTotales / 3600);
    // Calcula los minutos restantes
    const minutos = Math.floor((segundosTotales % 3600) / 60);
    // Calcula los segundos restantes
    const segundos = segundosTotales % 60;
    // Retorna un objeto con las conversiones
    return {
        horas,
        minutos,
        segundos,
        milisegundos
    };
}

/**
 * Extrae las variables definidas con `const`, `let` o `var` dentro de un fragmento de código y devuelve un objeto con sus valores.
 *
 * @param {string} text - El código fuente en formato de texto del cual se extraerán las variables.
 * @returns {Object} Un objeto donde las claves son los nombres de las variables y los valores son sus respectivos valores.
 *
 * @example
 * const code = `
 *     const x = 10;
 *     let y = 20;
 *     var z = 30;
 * `;
 * console.log(getVariablesInText(code)); // { x: 10, y: 20, z: 30 }
 */
export function getVariablesInText(text) {
    const variableRegex = /\b(?:const|let|var)\s+(\w+)\s*=/g;
    const variableNames = [...text.matchAll(variableRegex)].map(match => match[1]);

    if (variableNames.length === 0) {
        return {};
    }

    const functionBody = `${text}\nreturn { ${variableNames.join(", ")} };`;

    try {
        return new Function(functionBody)();
    } catch (error) {
        console.error("Error al evaluar el código:", error);
        return {};
    }
}

/**
 * Convierte una cadena de tiempo en formato "HH:MM:SS" a segundos.
 * @param {string} timeStr - La cadena de tiempo a convertir.
 * @returns {number} - El tiempo total en segundos.
 */
export function timeStringToSeconds(timeStr) {
    // Separa la cadena de tiempo en horas, minutos y segundos
    const [hours, minutes, seconds] = timeStr.split(':').map(Number);

    // Calcula el total de segundos: horas a segundos + minutos a segundos + segundos
    return hours * 3600 + minutes * 60 + seconds;
}

/**
 * Convierte un número total de segundos en una cadena de tiempo en formato HH:MM:SS.
 * @param {number} totalSeconds - El número total de segundos a convertir.
 * @returns {string} - La representación en cadena del tiempo en formato HH:MM:SS.
 */
export function secondsToTimeString(totalSeconds) {
    // Calcula las horas dividiendo el total de segundos por 3600 y redondeando hacia abajo.
    const hours = Math.floor(totalSeconds / 3600);

    // Calcula los minutos tomando el resto de la división de segundos por 3600 y dividiendo por 60.
    const minutes = Math.floor((totalSeconds % 3600) / 60);

    // Calcula los segundos tomando el resto de la división de totalSeconds por 60.
    const seconds = totalSeconds % 60;

    // Devuelve la cadena formateada en HH:MM:SS, asegurando que cada componente tenga dos dígitos.
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

/**
 * Aplica mixins a una clase base para extender su funcionalidad.
 * @param {...Function} mixins - Las funciones que representan los mixins a aplicar.
 * @returns {Function} - La nueva clase que combina la clase base y los mixins.
 *
 * @example
 * // Definimos algunas clases para usar como mixins
 *
 * // Mixin para agregar capacidades de natación
 * class Swimmer {
 *     swim() {
 *         console.log(`${this.name} está nadando.`);
 *     }
 *
 *     dive() {
 *         console.log(`${this.name} se sumerge bajo el agua.`);
 *     }
 * }
 *
 * // Mixin para agregar capacidades de vuelo
 * class Flyer {
 *     fly() {
 *         console.log(`${this.name} está volando.`);
 *     }
 *
 *     land() {
 *         console.log(`${this.name} aterriza suavemente.`);
 *     }
 * }
 *
 * // Mixin para agregar comportamientos de animal terrestre
 * class Walker {
 *     walk() {
 *         console.log(`${this.name} camina sobre la tierra.`);
 *     }
 *
 *     run() {
 *         console.log(`${this.name} corre rápidamente.`);
 *     }
 * }
 *
 * // Clase base Animal
 * class Animal {
 *     constructor(name) {
 *         this.name = name;
 *     }
 *
 *     eat() {
 *         console.log(`${this.name} está comiendo.`);
 *     }
 *
 *     sleep() {
 *         console.log(`${this.name} está durmiendo.`);
 *     }
 * }
 *
 * // Un pato puede caminar, nadar y volar
 * class Duck extends applyMixins(Walker, Swimmer, Flyer, Animal) {
 *     constructor(name) {
 *         super(name);
 *     }
 *
 *     quack() {
 *         console.log(`${this.name} hace cuac cuac!`);
 *     }
 * }
 *
 * const donald = new Duck("Donald");
 * donald.walk();     // Donald camina sobre la tierra.
 * donald.swim();     // Donald está nadando.
 * donald.fly();      // Donald está volando.
 * donald.quack();    // Donald hace cuac cuac!
 * donald.eat();      // Donald está comiendo.
 */
export function applyMixins(...mixins) {
    // Si no hay una clase base, creamos una base genérica
    let BaseClass = class {
        constructor(name) {
            this.name = name; // Inicializa la propiedad 'name' de la clase base
        }
    };

    // El último mixin puede ser una clase base personalizada
    if (mixins.length > 0 &amp;&amp; typeof mixins[mixins.length - 1] === 'function' &amp;&amp;
        mixins[mixins.length - 1].toString().startsWith('class')) {
        BaseClass = mixins.pop(); // Extrae la clase base personalizada de los mixins
    }

    // Creamos una clase que extiende de la clase base
    const MixedClass = class extends BaseClass {
        constructor(...args) {
            super(...args); // Llama al constructor de la clase base
        }
    };

    // Aplicamos cada mixin al prototipo de la nueva clase
    mixins.forEach(mixin => {
        const mixinProps = Object.getOwnPropertyDescriptors(mixin.prototype); // Obtiene las propiedades del prototipo del mixin
        // Excluimos constructor y propiedades del prototipo de Object
        delete mixinProps.constructor; // Elimina el constructor del mixin para evitar conflictos
        Object.defineProperties(MixedClass.prototype, mixinProps); // Define las propiedades del mixin en la nueva clase
    });

    return MixedClass; // Retorna la nueva clase que combina la funcionalidad de la clase base y los mixins
}

/**
 * Encuentra el objeto con el mayor número de elementos en una propiedad específica
 * @param {Array&lt;Object>} list - Lista de objetos a evaluar
 * @param {string} property - Nombre de la propiedad que contiene un array
 * @returns {Object|null} El objeto que tiene más elementos en la propiedad especificada, o null si hay error
 * @throws {Error} Si los parámetros no son válidos
 *
 * @example
 * const usuarios = [
 *   { nombre: 'Ana', hobbies: ['leer', 'correr'] },
 *   { nombre: 'Luis', hobbies: ['cocinar', 'viajar', 'fotografía'] },
 *   { nombre: 'María', hobbies: ['pintar'] }
 * ];
 *
 * const usuarioConMasHobbies = getMaxByProperty(usuarios, 'hobbies');
 * console.log(usuarioConMasHobbies);
 * // Output: { nombre: 'Luis', hobbies: ['cocinar', 'viajar', 'fotografía'] }
 *
 * // Casos especiales:
 * getMaxByProperty([], 'hobbies'); // returns null
 * getMaxByProperty(usuarios, 'propiedadInexistente'); // returns null
 */
export function getMaxByProperty(list, property) {
    // Validar parámetros
    if (!Array.isArray(list)) {
        throw new Error('El primer parámetro debe ser un array');
    }

    if (typeof property !== 'string') {
        throw new Error('El segundo parámetro debe ser un string');
    }

    // Lista vacía
    if (list.length === 0) {
        return null;
    }

    // Verificar que todos los objetos tengan la propiedad y que sea un array
    const validObjects = list.filter(obj =>
        obj &amp;&amp;
        typeof obj === 'object' &amp;&amp;
        obj.hasOwnProperty(property) &amp;&amp;
        Array.isArray(obj[property])
    );

    // Si no hay objetos válidos
    if (validObjects.length === 0) {
        return null;
    }

    return validObjects.reduce((greater, current) => {
        return current[property].length > greater[property].length ? current : greater;
    });
}

/**
 * Detecta el alfabeto utilizado en un texto dado.
 * @param {string} text - El texto a analizar.
 * @returns {Object} Un objeto con la cantidad de caracteres de cada alfabeto detectado.
 * @example
 * // Detectar alfabetos en texto mixto
 * const result = detectAlphabet("Hello مرحبا Привет");
 * console.log(result);
 * // Salida: { 'Latino': 5, 'Árabe': 5, 'Griego': 0, 'Cirílico': 6, ... }
 *
 * @example
 * // Detectar alfabeto en texto español
 * const result2 = detectAlphabet("Hola mundo");
 * console.log(result2);
 * // Salida: { 'Latino': 9, 'Árabe': 0, 'Griego': 0, 'Cirílico': 0, ... }
 */
export function detectAlphabet(text) {
    // Definir los rangos Unicode para diferentes alfabetos
    const ranges = {
        'Latino': [
            [0x0041, 0x005A], // A-Z
            [0x0061, 0x007A], // a-z
            [0x00C0, 0x00FF], // Latin-1 Supplement
            [0x0100, 0x017F], // Latin Extended-A
            [0x0180, 0x024F]  // Latin Extended-B
        ],
        'Árabe': [
            [0x0600, 0x06FF], // Arabic
            [0x0750, 0x077F], // Arabic Supplement
            [0x08A0, 0x08FF]  // Arabic Extended-A
        ],
        'Griego': [
            [0x0370, 0x03FF], // Greek and Coptic
            [0x1F00, 0x1FFF]  // Greek Extended
        ],
        'Cirílico': [
            [0x0400, 0x04FF], // Cyrillic
            [0x0500, 0x052F]  // Cyrillic Supplement
        ],
        'CJK (Chino/Japonés/Coreano)': [
            [0x4E00, 0x9FFF], // CJK Unified Ideographs
            [0x3040, 0x309F], // Hiragana
            [0x30A0, 0x30FF], // Katakana
            [0xAC00, 0xD7AF]  // Hangul Syllables
        ],
        'Hebreo': [
            [0x0590, 0x05FF]  // Hebrew
        ],
        'Devanagari': [
            [0x0900, 0x097F]  // Devanagari
        ],
        'Tailandés': [
            [0x0E00, 0x0E7F]  // Thai
        ]
    };

    // Contadores para cada alfabeto
    const indicators = {};
    Object.keys(ranges).forEach(alphabet => {
        indicators[alphabet] = 0; // Inicializar el contador para cada alfabeto en cero
    });

    // Analizar cada carácter del texto
    for (let i = 0; i &lt; text.length; i++) {
        const code = text.charCodeAt(i); // Obtener el código del carácter actual

        // Saltar espacios y caracteres de puntuación
        if (text[i].match(/[\s\d\p{P}]/u)) {
            continue; // Si es un espacio, dígito o puntuación, continuar con el siguiente carácter
        }

        // Verificar en qué rango cae el carácter
        for (const [alfabeto, alphabetRanges] of Object.entries(ranges)) {
            for (const [start, end] of alphabetRanges) {
                if (code >= start &amp;&amp; code &lt;= end) {
                    indicators[alfabeto]++; // Incrementar el contador del alfabeto correspondiente
                    break; // Salir del bucle una vez que se encuentra el rango
                }
            }
        }
    }

    return indicators; // Retornar el objeto con los contadores de cada alfabeto
}

/**
 * Obtiene el alfabeto principal basado en los contadores.
 * @param {Object} indicators - Un objeto con la cantidad de caracteres de cada alfabeto.
 * @returns {Object} Un objeto que contiene el alfabeto principal y la cantidad de caracteres.
 * @example
 * // Obtener alfabeto principal de contadores
 * const indicators = { 'Latino': 15, 'Árabe': 3, 'Griego': 0, 'Cirílico': 0 };
 * const main = getMainAlphabet(indicators);
 * console.log(main);
 * // Salida: { alphabet: 'Latino', characters: 15 }
 *
 * @example
 * // Uso combinado con detectAlphabet
 * const text = "Здравствуй мир!";
 * const indicators = detectAlphabet(text);
 * const mainAlphabet = getMainAlphabet(indicators);
 * console.log(mainAlphabet);
 * // Salida: { alphabet: 'Cirílico', characters: 12 }
 */
export function getMainAlphabet(indicators) {
    let maxCount = 0; // Inicializar el contador máximo en cero

    let mainAlphabet = 'Desconocido'; // Inicializar el alfabeto principal como desconocido

    for (const [alphabet, count] of Object.entries(indicators)) {
        if (count > maxCount) {
            maxCount = count; // Actualizar el contador máximo
            mainAlphabet = alphabet; // Actualizar el alfabeto principal
        }
    }

    return {
        alphabet: mainAlphabet, // Retornar el alfabeto principal
        characters: maxCount // Retornar la cantidad de caracteres del alfabeto principal
    };
}

/**
 * Clase para procesar productos desde un estado normalizado
 * @example
 * // Ejemplo básico
 * const processor = new ProductStateProcessor();
 * const slug = 'algo-que-identifique-el-producto'
 * const products = processor.getProducts(state);
 *
 * // Ejemplo con opciones personalizadas
 * const slug = 'algo-que-identifique-el-producto'
 * const products = processor.getProducts(state, {
 *     regexProduct: new RegExp('Product:' + slug + '$'),
 *     predicateItems: (value) => value.startsWith('items'),
 *     predicateInstallments: (value) => value.startsWith('Installments')
 * });
 */
class ProductStateProcessor {
    constructor(options = {}) {
        this.defaultRegex = new RegExp(/Product:(sp\-)?\d+(\-none)?$/);
        this.defaultPredicateItems = (value) => value.startsWith('items({');
        this.defaultPredicateInstallments = (value) => value.startsWith('Installments({');

        // Configuración personalizable
        this.config = {
            regexProduct: options.regexProduct || this.defaultRegex,
            predicateItems: options.predicateItems || this.defaultPredicateItems,
            predicateInstallments: options.predicateInstallments || this.defaultPredicateInstallments,
            removeInstallments: options.removeInstallments !== false, // true por defecto
            removePriceRange: options.removePriceRange !== false // true por defecto
        };
    }

    /**
     * Obtiene productos procesados desde el estado
     * @param {Object} state - Estado normalizado que contiene los productos
     * @param {Object} options - Opciones específicas para esta operación
     * @returns {Array|Object} - Productos procesados
     */
    getProducts(state, options = {}) {
        this.validateInputs(state, options);

        const config = { ...this.config, ...options };
        const products = [];

        for (const key in state) {
            if (this.isProductKey(key, config.regexProduct)) {
                const product = this.processProduct(state, key, config);
                if (product) {
                    products.push(product);
                }
            }
        }

        return this.unwrapIfOnlyOne(products);
    }

    /**
     * Valida las entradas de la función principal
     */
    validateInputs(state, options) {
        if (!this.isObject(state)) {
            throw new TypeError('El state debe ser un objeto');
        }

        if (options.regexProduct &amp;&amp; !this.isRegExp(options.regexProduct)) {
            throw new TypeError('El regexProduct debe ser un objeto RegExp');
        }

        if (options.predicateItems &amp;&amp; !this.isFunction(options.predicateItems)) {
            throw new TypeError('El predicateItems debe ser una función predicado');
        }

        if (options.predicateInstallments &amp;&amp; !this.isFunction(options.predicateInstallments)) {
            throw new TypeError('El predicateInstallments debe ser una función predicado');
        }
    }

    /**
     * Verifica si una clave corresponde a un producto
     */
    isProductKey(key, regex) {
        return regex.test(key);
    }

    /**
     * Procesa un producto individual
     */
    processProduct(state, key, config) {
        try {
            const product = { ...state[key] };

            // Limpieza inicial
            if (config.removePriceRange) {
                delete product.priceRange;
            }

            // Procesamiento de diferentes secciones del producto
            this.processSpecificationGroups(product, state);
            this.processSkuSpecifications(product, state);
            this.processProductClusters(product, state);
            this.processClusterHighlights(product, state);
            this.processProperties(product, state);
            this.processItemMetadata(product, state);
            this.processVariants(product, state, config);
            this.processItemMetadataWithAssemblyOptions(product, state);

            return product;
        } catch (error) {
            console.warn(`Error procesando producto ${key}:`, error);
            return null;
        }
    }

    /**
     * Procesa grupos de especificaciones
     */
    processSpecificationGroups(product, state) {
        if (!product.specificationGroups) return;

        const processedGroups = product.specificationGroups.map(({ id }) => {
            const groupData = state[id];
            if (!groupData) return null;

            const { name, originalName, specifications } = groupData;

            // Procesar especificaciones individualmente
            const processedSpecs = specifications ? specifications.map(({ id: specId }) => {
                const specData = state[specId];
                if (!specData) return null;

                return {
                    name: specData.name,
                    originalName: specData.originalName,
                    values: specData.values
                };
            }).filter(Boolean) : [];

            return {
                name,
                originalName,
                properties: this.unwrapIfOnlyOne(processedSpecs)
            };
        }).filter(Boolean);

        product.specificationGroups = this.unwrapIfOnlyOne(processedGroups);
    }

    /**
     * Procesa especificaciones de SKU
     */
    processSkuSpecifications(product, state) {
        if (!product.skuSpecifications) return;

        const processedSpecs = product.skuSpecifications.map(({ id }) => {
            const specData = state[id];
            if (!specData?.field?.id) return null;

            const fieldData = state[specData.field.id];
            if (!fieldData) return null;

            return {
                name: fieldData.name,
                originalName: fieldData.originalName,
                properties: this.resolveReferences(specData.values, state)
            };
        }).filter(Boolean);

        product.skuSpecifications = this.unwrapIfOnlyOne(processedSpecs);
    }

    /**
     * Procesa clusters de productos
     */
    processProductClusters(product, state) {
        if (product.productClusters) {
            product.productClusters = this.resolveReferences(product.productClusters, state);
        }
    }

    /**
     * Procesa highlights de clusters
     */
    processClusterHighlights(product, state) {
        if (product.clusterHighlights) {
            product.clusterHighlights = this.resolveReferences(product.clusterHighlights, state);
        }
    }

    /**
     * Procesa propiedades del producto
     */
    processProperties(product, state) {
        if (!product.properties) return;

        const processedProperties = product.properties.map(({ id }) => {
            const propertyData = state[id];
            if (!propertyData) return null;

            return {
                name: propertyData.name,
                values: propertyData.values
            };
        }).filter(Boolean);

        product.properties = this.unwrapIfOnlyOne(processedProperties);
    }

    /**
     * Procesa metadata de items
     */
    processItemMetadata(product, state) {
        if (!product.itemMetadata) return;

        const metadataArray = Array.isArray(product.itemMetadata)
            ? product.itemMetadata
            : [product.itemMetadata];

        const processedMetadata = metadataArray.map(({ id }) => {
            const metadataItem = state[id];
            if (!metadataItem?.items) return null;

            return metadataItem.items.map(({ id: itemId }) => {
                return { ...state[itemId] };
            });
        }).filter(Boolean).flat();

        product.itemMetadata = this.unwrapIfOnlyOne(processedMetadata);
    }

    /**
     * Busca la clave de la tabla de precios
     */
    findPriceTableKey(state, baseId, itemId) {
        const baseKey = baseId.split('.items.')[0];
        return Object.keys(state).find(key =>
            key.startsWith(baseKey) &amp;&amp; state[key]?.id === itemId
        );
    }

    /**
     * Procesa variantes del producto
     */
    processVariants(product, state, config) {
        const itemsKey = Object.keys(product).find(k => config.predicateItems(k));
        if (!itemsKey) return;

        const variants = product[itemsKey];
        product.variants = variants.map(({ id }) => this.processVariant(state, id, config));



        delete product[itemsKey];
    }

    /**
     * Procesa una variante individual
     */
    processVariant(state, variantId, config) {
        const variant = { ...state[variantId] };

        // Procesar diferentes propiedades de la variante
        if (variant.variations) {
            variant.variations = this.resolveReferences(variant.variations, state);
        }

        if (variant.referenceId) {
            variant.referenceId = this.resolveReferences(variant.referenceId, state);
        }

        if (variant.attachments) {
            variant.attachments = this.resolveReferences(variant.attachments, state);
        }

        if (variant.images) {
            variant.images = this.resolveReferences(variant.images, state);
        }

        if (variant.sellers) {
            variant.sellers = this.processSellers(variant.sellers, state, config);
        }

        return variant;
    }

    /**
     * Procesa vendedores de una variante
     */
    processSellers(sellers, state, config) {
        const processedSellers = sellers.map(({ id: sellerId }) => {
            const seller = { ...state[sellerId] };

            if (seller.commertialOffer) {
                seller.commertialOffer = this.processCommercialOffer(
                    seller.commertialOffer,
                    state,
                    config
                );
            }

            return seller;
        });

        return this.unwrapIfOnlyOne(processedSellers);
    }

    /**
     * Procesa oferta comercial
     */
    processCommercialOffer(commercialOffer, state, config) {
        const offer = { ...state[commercialOffer.id] };

        if (config.removeInstallments) {
            const installmentsKey = Object.keys(offer).find(k =>
                config.predicateInstallments(k)
            );
            if (installmentsKey) {
                delete offer[installmentsKey];
            }
        }

        return this.unwrapIfOnlyOne(offer);
    }

    /**
     * Procesa metadata de items con opciones de ensamblaje
     */
    processItemMetadataWithAssemblyOptions(product, state) {
        if (!product.variants?.length || !product.itemMetadata?.length) return;

        const variantIds = this.extractVariantIds(product.variants);
        const itemsWithAssembly = product.itemMetadata.filter(im =>
            variantIds.includes(im.id)
        );

        if (itemsWithAssembly.length > 0) {
            product.itemMetadataWithAssembyOptions = itemsWithAssembly.map(item => ({
                ...item,
                assemblyOptions: this.processAssemblyOptions(item.assemblyOptions, state)
            }));

            product.itemMetadata = product.itemMetadata.filter(im =>
                !variantIds.includes(im.id)
            );
        }
    }

    /**
     * Extrae IDs de variantes
     */
    extractVariantIds(variants) {
        return variants.map(v => v.itemId || v.id);
    }

    /**
     * Procesa opciones de ensamblaje
     */
    processAssemblyOptions(assemblyOptions, state) {
        if (!assemblyOptions) return [];

        const resolvedOptions = this.resolveReferences(assemblyOptions, state);

        return resolvedOptions.map(opt => {
            const processedOpt = { ...opt };

            if (processedOpt.composition) {
                processedOpt.composition = {
                    ...processedOpt.composition,
                    ...state[processedOpt.composition.id]
                };

                if (processedOpt.composition.items) {
                    processedOpt.composition.items = this.resolveReferences(
                        processedOpt.composition.items,
                        state
                    );
                }
            }

            if (processedOpt.inputValues?.length > 0) {
                processedOpt.inputValues = this.resolveReferences(
                    processedOpt.inputValues,
                    state
                );
            }

            return processedOpt;
        });
    }

    /**
     * Resuelve referencias en el estado
     */
    resolveReferences(items, state) {
        if (!items?.length) return [];

        const resolvedItems = items
            .map(item => {
                // Manejar tanto objetos con ID como IDs directos
                const id = typeof item === 'object' ? item.id : item;
                const resolvedItem = state[id];

                // Si el item original tiene datos de tipo JSON, preservarlos
                if (resolvedItem &amp;&amp; item.values?.json) {
                    return {
                        ...resolvedItem,
                        values: item.values
                    };
                }

                return resolvedItem;
            })
            .filter(Boolean); // Filtrar elementos nulos/undefined

        return this.unwrapIfOnlyOne(resolvedItems);
    }

    /**
     * Extrae valores JSON de propiedades
     */
    extractJsonValues(property) {
        if (property?.values?.type === 'json' &amp;&amp; property.values.json) {
            return Array.isArray(property.values.json) ?
                property.values.json : [property.values.json];
        }
        return [];
    }

    /**
     * Busca productos por especificación
     */
    findProductsBySpecification(products, specName, searchValue) {
        const productArray = Array.isArray(products) ? products : [products];

        return this.unwrapIfOnlyOne(productArray.filter(product => {
            if (!product.properties) return false;

            const props = Array.isArray(product.properties) ?
                product.properties : [product.properties];

            return props.some(prop => {
                if (prop.name === specName) {
                    const values = this.extractJsonValues(prop);
                    return values.some(value =>
                        value.toLowerCase().includes(searchValue.toLowerCase())
                    );
                }
                return false;
            });
        }));
    }

    /**
     * Obtiene información de precios simplificada
     */
    getPriceInfo(products) {
        const productArray = Array.isArray(products) ? products : [products];

        return this.unwrapIfOnlyOne(productArray.map(product => {
            const priceInfo = {
                productName: product.productName,
                productId: product.productId,
                brand: product.brand,
                variants: []
            };

            if (product.variants) {
                const variants = Array.isArray(product.variants) ?
                    product.variants : [product.variants];

                variants.forEach(variant => {
                    const variantInfo = {
                        name: variant.name,
                        itemId: variant.itemId,
                        sellers: []
                    };

                    if (variant.sellers) {
                        const sellers = Array.isArray(variant.sellers) ?
                            variant.sellers : [variant.sellers];

                        sellers.forEach(seller => {
                            if (seller.commertialOffer) {
                                variantInfo.sellers.push({
                                    sellerName: seller.sellerName,
                                    sellerId: seller.sellerId,
                                    price: seller.commertialOffer.Price,
                                    listPrice: seller.commertialOffer.ListPrice,
                                    spotPrice: seller.commertialOffer.spotPrice,
                                    availableQuantity: seller.commertialOffer.AvailableQuantity,
                                    priceValidUntil: seller.commertialOffer.PriceValidUntil
                                });
                            }
                        });
                    }

                    priceInfo.variants.push(variantInfo);
                });
            }

            return priceInfo;
        }));
    }

    /**
     * Desenvuelve un array si solo tiene un elemento
     */
    unwrapIfOnlyOne(list) {
        return list?.length === 1 ? list[0] : list;
    }

    // Métodos utilitarios de validación
    isObject(value) {
        return value !== null &amp;&amp; typeof value === 'object' &amp;&amp; !Array.isArray(value);
    }

    isFunction(value) {
        return typeof value === 'function';
    }

    isRegExp(value) {
        return value instanceof RegExp;
    }
}

/**
 * Extrae todos los objetos de un array anidado y elimina la propiedad children
 * @param {Array} inputArray - Array base que puede contener strings, null, objects, arrays
 * @returns {Array} - Array limpio con solo objetos sin propiedad children
 */
function extractCleanObjects(inputArray) {
    const result = [];

    /**
     * Función auxiliar recursiva para procesar elementos
     * @param {*} element - Elemento a procesar
     */
    function processElement(element) {
        // Si es null o undefined, ignorar
        if (element == null) {
            return;
        }

        // Si es string, ignorar
        if (typeof element === 'string') {
            return;
        }

        // Si es array, procesar cada elemento
        if (Array.isArray(element)) {
            element.forEach(processElement);
            return;
        }

        // Si es objeto (y no es array)
        if (typeof element === 'object') {
            // Crear copia del objeto sin la propiedad children
            const cleanObject = { ...element };

            // Si tiene children, procesarlos recursivamente antes de eliminar la propiedad
            if (element.children &amp;&amp; Array.isArray(element.children)) {
                element.children.forEach(processElement);
            }

            // Eliminar la propiedad children
            delete cleanObject.children;

            // Agregar el objeto limpio al resultado
            result.push(cleanObject);
        }
    }

    // Procesar cada elemento del array de entrada
    inputArray.forEach(processElement);

    return result.filter(element => Object.keys(element).length > 0);
}

/**
 * Convierte una cadena de tiempo en formato "HH:MM:SS" a la unidad deseada.
 *
 * @param {string} timeStr - La cadena de tiempo a convertir (ejemplo: "01:23:45").
 * @param {"seconds"|"minutes"|"hours"|"milliseconds"} [unit="seconds"] - La unidad de salida (por defecto "seconds").
 * @returns {number} - El tiempo total convertido a la unidad indicada.
 *
 * @example
 * timeStringTo("01:23:45"); // 5025 (segundos)
 * timeStringTo("01:23:45", "minutes"); // 83.75 (minutos)
 * timeStringTo("01:23:45", "hours"); // 1.3958... (horas)
 * timeStringTo("01:23:45", "milliseconds"); // 5025000 (ms)
 */
function timeStringTo(timeStr, unit = "seconds") {
    const [hours = 0, minutes = 0, seconds = 0, milliseconds = 0] = timeStr.split(':').map(Number);
    const totalSeconds = hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;

    switch (unit) {
        case "seconds": return totalSeconds;
        case "minutes": return totalSeconds / 60;
        case "hours": return totalSeconds / 3600;
        case "milliseconds": return totalSeconds * 1000;
        default: throw new Error(`Unidad no soportada: ${unit}`);
    }
}

/**
 * Convierte un número de tiempo en una cadena formateada.
 *
 * @param {number} timeNumber - El número de tiempo a convertir.
 * @param {"seconds"|"minutes"|"hours"|"milliseconds"} [unit="seconds"] - La unidad de tiempo de entrada.
 * @param {"s"|"m"|"l"} [format="m"] - El formato de salida:
 *   - `"s"` → "HH:MM"
 *   - `"m"` → "HH:MM:SS"
 *   - `"l"` → "HH:MM:SS.mmm"
 * @returns {string} - La representación en cadena del tiempo formateado.
 *
 * @example
 * timeToString(5025); // "01:23:45" (por defecto segundos y formato medio)
 * timeToString(83.75, "minutes"); // "01:23:45"
 * timeToString(1.3958, "hours", "s"); // "01:23"
 * timeToString(5025000, "milliseconds", "l"); // "01:23:45.000"
 */
function timeToString(timeNumber, unit = 'seconds', format = 'm') {
    let totalSeconds = 0;
    switch (unit) {
        case "seconds": totalSeconds = timeNumber; break;
        case "minutes": totalSeconds = timeNumber * 60; break;
        case "hours": totalSeconds = timeNumber * 3600; break;
        case "milliseconds": totalSeconds = timeNumber / 1000; break;
        default: throw new Error(`Unidad no soportada: ${unit}`);
    }

    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = Math.floor(totalSeconds % 60);
    const milliseconds = Math.floor((totalSeconds % 1) * 1000);

    switch (format) {
        case 's': return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        case 'm': return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        case 'l': return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
        default: throw new Error(`Formato no soportado: ${format}`);
    }
}

/**
 * Función que ordena elementos basándose en un arreglo de referencia.
 * Los elementos no encontrados en el arreglo de referencia se colocan al final.
 * @param {Array} elements - Arreglo de elementos a ordenar.
 * @param {Array} referenceArray - Arreglo que define el orden deseado.
 * @param {string} property - Propiedad del elemento que se utilizará para la comparación.
 * @param {boolean} [includeNotFound=false] - Si incluir elementos no encontrados al final.
 * @param {boolean} [trimValues=true] - Si aplicar trim a los valores de la propiedad.
 * @returns {Array} - Arreglo de elementos ordenados según el arreglo de referencia.
 * 
 * @example
 * const testElements = [
 *   { id: 1, categoria: 'frutas', nombre: 'Manzana' },
 *   { id: 2, categoria: 'verduras', nombre: 'Zanahoria' },
 *   { id: 3, categoria: 'carnes', nombre: 'Pollo' },
 *   { id: 4, categoria: 'lacteos', nombre: 'Leche' },
 *   { id: 5, categoria: 'cereales', nombre: 'Arroz' }, // No está en el orden
 * ];
 * 
 * const ordenDeseado = ['lacteos', 'frutas', 'verduras', 'carnes'];
 * 
 * const resultado = sortElementsByReferenceArray(testElements, ordenDeseado, 'categoria');
 * console.log(resultado);
 */
function sortElementsByReferenceArray(elements, referenceArray, property, includeNotFound = false, trimValues = true) {
    // Validación de entrada
    if (!elements?.length || !referenceArray?.length) return [...elements] || [];
    
    // Crear mapa de índices para eficiencia O(1) lookup
    const indexMap = new Map();
    referenceArray.forEach((item, index) => {
        const key = trimValues &amp;&amp; typeof item === 'string' ? item.trim() : item;
        indexMap.set(key, index);
    });
    
    // Función para obtener el valor de comparación
    const getComparisonValue = (element) => {
        const value = element[property];
        return trimValues &amp;&amp; typeof value === 'string' ? value.trim() : value;
    };
    
    // Separar elementos encontrados y no encontrados
    const found = [];
    const notFound = [];
    
    elements.forEach(element => {
        const comparisonValue = getComparisonValue(element);
        if (indexMap.has(comparisonValue)) {
            found.push({
                element,
                index: indexMap.get(comparisonValue)
            });
        } else if (includeNotFound) {
            notFound.push(element);
        }
    });
    
    // Ordenar elementos encontrados por su índice en el arreglo de referencia
    found.sort((a, b) => a.index - b.index);
    
    // Retornar elementos ordenados
    const sortedFound = found.map(item => item.element);
    return includeNotFound ? [...sortedFound, ...notFound] : sortedFound;
}

/**
 * Ordena un arreglo de objetos basándose en un arreglo de referencia sin mutar el arreglo original.
 * Los elementos que no se encuentren en el arreglo de referencia se colocan al final.
 * 
 * @param {Array&lt;Object>} objects - Arreglo de objetos a ordenar.
 * @param {Array&lt;string|number>} referenceArray - Arreglo que define el orden deseado.
 * @param {string} property - Nombre de la propiedad del objeto que se usará para la comparación.
 * @returns {Array&lt;Object>} - Nuevo arreglo ordenado según el arreglo de referencia.
 * 
 * @example
 * // Ordenar productos por categorías específicas
 * const products = [
 *   { id: 1, category: 'electronics', name: 'Laptop' },
 *   { id: 2, category: 'clothing', name: 'Shirt' },
 *   { id: 3, category: 'books', name: 'Novel' },
 *   { id: 4, category: 'electronics', name: 'Phone' },
 *   { id: 5, category: 'sports', name: 'Ball' }
 * ];
 * 
 * const categoryOrder = ['books', 'electronics', 'clothing'];
 * const sortedProducts = sortByArray(products, categoryOrder, 'category');
 * 
 * // Resultado: books → electronics → clothing → sports (al final)
 * console.log(sortedProducts);
 * // [
 * //   { id: 3, category: 'books', name: 'Novel' },
 * //   { id: 1, category: 'electronics', name: 'Laptop' },
 * //   { id: 4, category: 'electronics', name: 'Phone' },
 * //   { id: 2, category: 'clothing', name: 'Shirt' },
 * //   { id: 5, category: 'sports', name: 'Ball' }
 * // ]
 */
function sortByArray(objects, referenceArray, property) {
  // Crear una copia del array para no mutar el original
  const copy = [...objects];
  
  return copy.sort((a, b) => {
    const valueA = a[property];
    const valueB = b[property];
    
    const indexA = referenceArray.indexOf(valueA);
    const indexB = referenceArray.indexOf(valueB);
    
    if (indexA !== -1 &amp;&amp; indexB !== -1) {
      return indexA - indexB;
    }
    
    if (indexA !== -1 &amp;&amp; indexB === -1) {
      return -1;
    }
    
    if (indexA === -1 &amp;&amp; indexB !== -1) {
      return 1;
    }
    
    return 0;
  });
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Hecho con <small>❤</small> por <a
        href="https://github.com/xdany01">@xdany01</a> usando la plantilla de <a
        href="https://github.com/clenemt/docdash">docdash</a>.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
